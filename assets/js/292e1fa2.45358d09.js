"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[8247],{1651(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-3-ai-brain/summary","title":"Module 3 Summary: The AI-Robot Brain (NVIDIA Isaac)","description":"Overview","source":"@site/docs/module-3-ai-brain/summary.md","sourceDirName":"module-3-ai-brain","slug":"/module-3-ai-brain/summary","permalink":"/Book-ai-native/docs/module-3-ai-brain/summary","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/module-3-ai-brain/summary.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Lab: Isaac Perception System","permalink":"/Book-ai-native/docs/module-3-ai-brain/lab-perception-system"},"next":{"title":"Module 4: Vision-Language-Action (VLA)","permalink":"/Book-ai-native/docs/module-4-vla/intro"}}');var r=i(4848),l=i(8453);const t={sidebar_position:9},o="Module 3 Summary: The AI-Robot Brain (NVIDIA Isaac)",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts Learned",id:"key-concepts-learned",level:2},{value:"1. Isaac Platform Architecture",id:"1-isaac-platform-architecture",level:3},{value:"2. Perception Pipeline Development",id:"2-perception-pipeline-development",level:3},{value:"3. Neural Network Inference Optimization",id:"3-neural-network-inference-optimization",level:3},{value:"4. Path Planning and Motion Planning",id:"4-path-planning-and-motion-planning",level:3},{value:"5. Manipulation Control Systems",id:"5-manipulation-control-systems",level:3},{value:"6. GPU Optimization Techniques",id:"6-gpu-optimization-techniques",level:3},{value:"Technical Skills Acquired",id:"technical-skills-acquired",level:2},{value:"Software Development Skills",id:"software-development-skills",level:3},{value:"System Integration Skills",id:"system-integration-skills",level:3},{value:"Performance Optimization Skills",id:"performance-optimization-skills",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Industrial Robotics",id:"industrial-robotics",level:3},{value:"Service Robotics",id:"service-robotics",level:3},{value:"Research and Development",id:"research-and-development",level:3},{value:"Best Practices and Guidelines",id:"best-practices-and-guidelines",level:2},{value:"Development Best Practices",id:"development-best-practices",level:3},{value:"Performance Optimization Guidelines",id:"performance-optimization-guidelines",level:3},{value:"Safety and Reliability",id:"safety-and-reliability",level:3},{value:"Integration with Other Modules",id:"integration-with-other-modules",level:2},{value:"Challenges and Considerations",id:"challenges-and-considerations",level:2},{value:"Technical Challenges",id:"technical-challenges",level:3},{value:"Practical Considerations",id:"practical-considerations",level:3},{value:"Future Directions",id:"future-directions",level:2},{value:"Emerging Technologies",id:"emerging-technologies",level:3},{value:"Research Areas",id:"research-areas",level:3},{value:"Summary of Key Equations and Formulas",id:"summary-of-key-equations-and-formulas",level:2},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Path Planning",id:"path-planning",level:3},{value:"GPU Memory",id:"gpu-memory",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"References",id:"references",level:2}];function d(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"module-3-summary-the-ai-robot-brain-nvidia-isaac",children:"Module 3 Summary: The AI-Robot Brain (NVIDIA Isaac)"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:'Module 3 has provided a comprehensive exploration of the AI components that serve as the "brain" of modern robotic systems. We\'ve examined NVIDIA Isaac, a comprehensive platform that combines hardware acceleration, AI frameworks, and robotics middleware to create intelligent robotic systems capable of perception, reasoning, and action in complex environments.'}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts-learned",children:"Key Concepts Learned"}),"\n",(0,r.jsx)(n.h3,{id:"1-isaac-platform-architecture",children:"1. Isaac Platform Architecture"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac Sim"}),": High-fidelity simulation environment built on NVIDIA Omniverse"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac ROS"}),": Robot Operating System packages for GPU-accelerated perception"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac Lab"}),": Framework for robot learning and deployment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac Apps"}),": Pre-built applications for common robotics tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DeepStream"}),": Streaming analytics toolkit for multi-sensor processing"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-perception-pipeline-development",children:"2. Perception Pipeline Development"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-sensor Integration"}),": Combining camera, LiDAR, and other sensor modalities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GPU Acceleration"}),": Leveraging CUDA and Tensor cores for real-time processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time Performance"}),": Optimizing pipelines for consistent frame rates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robustness"}),": Handling edge cases and failure scenarios in perception systems"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-neural-network-inference-optimization",children:"3. Neural Network Inference Optimization"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TensorRT"}),": NVIDIA's high-performance inference optimizer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quantization Techniques"}),": FP16 and INT8 optimization for edge deployment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Management"}),": Efficient GPU memory allocation and usage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance Profiling"}),": Tools and techniques for measuring inference performance"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-path-planning-and-motion-planning",children:"4. Path Planning and Motion Planning"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Classical Algorithms"}),": A*, Dijkstra, and RRT implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration Space"}),": Understanding C-space for robot navigation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Planning"}),": Handling moving obstacles and replanning scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manipulation Planning"}),": Joint-space planning for robotic arms"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-manipulation-control-systems",children:"5. Manipulation Control Systems"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kinematics"}),": Forward and inverse kinematics for robotic arms"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp Planning"}),": Strategies for stable object manipulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Force Control"}),": Impedance and hybrid position/force control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tactile Sensing"}),": Integration of touch feedback for dexterous manipulation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"6-gpu-optimization-techniques",children:"6. GPU Optimization Techniques"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CUDA Programming"}),": Writing efficient GPU kernels for robotics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Optimization"}),": Coalescing, shared memory, and memory pools"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Heterogeneous Computing"}),": Balancing CPU and GPU workloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance Profiling"}),": Tools for measuring and optimizing GPU performance"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"technical-skills-acquired",children:"Technical Skills Acquired"}),"\n",(0,r.jsx)(n.h3,{id:"software-development-skills",children:"Software Development Skills"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implementing GPU-accelerated robotics algorithms using CUDA"}),"\n",(0,r.jsx)(n.li,{children:"Integrating Isaac ROS packages with custom robotics applications"}),"\n",(0,r.jsx)(n.li,{children:"Optimizing neural networks for real-time inference on edge hardware"}),"\n",(0,r.jsx)(n.li,{children:"Developing robust perception pipelines with multiple sensor inputs"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"system-integration-skills",children:"System Integration Skills"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Configuring Isaac development environments with Docker"}),"\n",(0,r.jsx)(n.li,{children:"Creating ROS 2 packages that interface with Isaac ROS"}),"\n",(0,r.jsx)(n.li,{children:"Building complete perception systems with detection, segmentation, and tracking"}),"\n",(0,r.jsx)(n.li,{children:"Deploying AI-robotics systems on edge hardware platforms"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimization-skills",children:"Performance Optimization Skills"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Profiling GPU utilization and memory usage"}),"\n",(0,r.jsx)(n.li,{children:"Optimizing memory access patterns for coalescing"}),"\n",(0,r.jsx)(n.li,{children:"Balancing computational load between CPU and GPU"}),"\n",(0,r.jsx)(n.li,{children:"Implementing efficient data structures for real-time processing"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,r.jsx)(n.p,{children:"The concepts and techniques covered in this module apply to numerous real-world robotics applications:"}),"\n",(0,r.jsx)(n.h3,{id:"industrial-robotics",children:"Industrial Robotics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Autonomous mobile robots (AMRs) for warehouse automation"}),"\n",(0,r.jsx)(n.li,{children:"Robotic arms for assembly and quality inspection"}),"\n",(0,r.jsx)(n.li,{children:"Automated guided vehicles (AGVs) for material handling"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"service-robotics",children:"Service Robotics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Delivery robots navigating urban environments"}),"\n",(0,r.jsx)(n.li,{children:"Healthcare robots assisting with patient care"}),"\n",(0,r.jsx)(n.li,{children:"Retail robots for inventory management and customer assistance"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"research-and-development",children:"Research and Development"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Laboratory robots for scientific experiments"}),"\n",(0,r.jsx)(n.li,{children:"Agricultural robots for precision farming"}),"\n",(0,r.jsx)(n.li,{children:"Construction robots for automated building tasks"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-and-guidelines",children:"Best Practices and Guidelines"}),"\n",(0,r.jsx)(n.h3,{id:"development-best-practices",children:"Development Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modular Design"}),": Structure perception systems with clear component separation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time Considerations"}),": Design algorithms with timing constraints in mind"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robustness"}),": Implement fallback mechanisms for when primary systems fail"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": Continuously validate perception outputs against ground truth"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimization-guidelines",children:"Performance Optimization Guidelines"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GPU Utilization"}),": Maximize GPU occupancy while respecting memory constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Management"}),": Use memory pools to reduce allocation overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Pipeline"}),": Optimize data flow between processing stages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Profiling"}),": Regularly measure performance to identify bottlenecks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"safety-and-reliability",children:"Safety and Reliability"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundancy"}),": Implement multiple perception methods when safety is critical"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": Continuously validate perception outputs for plausibility"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitoring"}),": Implement comprehensive logging and monitoring systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Develop extensive test suites covering edge cases"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-other-modules",children:"Integration with Other Modules"}),"\n",(0,r.jsx)(n.p,{children:"Module 3 builds upon the ROS 2 foundation established in Module 1 and the simulation concepts from Module 2:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 1 Connection"}),": Isaac ROS packages integrate seamlessly with ROS 2 systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 2 Connection"}),": Perception systems process data from simulated sensors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 4 Connection"}),": AI brain components enable the vision-language-action capabilities"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"challenges-and-considerations",children:"Challenges and Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Computational Requirements"}),": Balancing performance with power consumption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Latency Constraints"}),": Meeting real-time requirements for control systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robustness"}),": Handling varying environmental conditions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": Designing systems that work across different robot platforms"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"practical-considerations",children:"Practical Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware Selection"}),": Choosing appropriate GPU platforms for specific applications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Development Costs"}),": Balancing performance requirements with budget constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintenance"}),": Ensuring long-term maintainability of complex AI systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regulatory Compliance"}),": Meeting safety and certification requirements"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"future-directions",children:"Future Directions"}),"\n",(0,r.jsx)(n.h3,{id:"emerging-technologies",children:"Emerging Technologies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transformer Architectures"}),": Attention mechanisms for robotics perception"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Neural Radiance Fields"}),": 3D scene representation from 2D images"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Foundation Models"}),": Large-scale pre-trained models for robotics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge AI Chips"}),": Specialized hardware for robotics applications"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"research-areas",children:"Research Areas"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Continual Learning"}),": Robots that learn and adapt over time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-modal Integration"}),": Better fusion of different sensor modalities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Human-Robot Interaction"}),": More intuitive and natural interaction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Embodied AI"}),": AI systems that understand the physical world"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary-of-key-equations-and-formulas",children:"Summary of Key Equations and Formulas"}),"\n",(0,r.jsx)(n.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FPS (Frames Per Second)"}),": 1 / average processing time per frame"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GPU Utilization"}),": (active cycles / total cycles) \xd7 100%"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Bandwidth Utilization"}),": (actual bandwidth / theoretical peak) \xd7 100%"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"path-planning",children:"Path Planning"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.em,{children:[(0,r.jsx)(n.em,{children:"A"})," Cost Function"]}),"*: f(n) = g(n) + h(n)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"g(n): actual cost from start to node n"}),"\n",(0,r.jsx)(n.li,{children:"h(n): heuristic cost from node n to goal"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"gpu-memory",children:"GPU Memory"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Theoretical Bandwidth"}),": memory clock \xd7 bus width \xd7 2 (for DDR) / 8"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Achieved Bandwidth"}),": bytes transferred / time taken"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"With Module 3 completed, you now have a solid foundation in AI-powered robotics using NVIDIA Isaac. The next module (Module 4) will explore Vision-Language-Action (VLA) models, which integrate the perception and control capabilities learned here with advanced AI that can understand and respond to natural language commands."}),"\n",(0,r.jsx)(n.p,{children:"The integration of these capabilities will enable you to build truly intelligent robotic systems that can understand human instructions and execute complex tasks in real-world environments."}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(n.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>t,x:()=>o});var s=i(6540);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);