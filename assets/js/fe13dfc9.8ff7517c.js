"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[8634],{2110(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"capstone/navigation","title":"Navigation and Obstacle Avoidance: Autonomous Humanoid Capstone","description":"Overview","source":"@site/docs/capstone/navigation.md","sourceDirName":"capstone","slug":"/capstone/navigation","permalink":"/Book-ai-native/docs/capstone/navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/capstone/navigation.md","tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18},"sidebar":"tutorialSidebar","previous":{"title":"Task Planning and Execution: Autonomous Humanoid Capstone","permalink":"/Book-ai-native/docs/capstone/task-planning"},"next":{"title":"Object Detection and Manipulation: Autonomous Humanoid Capstone","permalink":"/Book-ai-native/docs/capstone/object-detection"}}');var a=r(4848),o=r(8453);const s={sidebar_position:18},i="Navigation and Obstacle Avoidance: Autonomous Humanoid Capstone",l={},c=[{value:"Overview",id:"overview",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Navigation Stack Architecture",id:"navigation-stack-architecture",level:3},{value:"Integration with Other Systems",id:"integration-with-other-systems",level:3},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"1. Global Path Planning",id:"1-global-path-planning",level:3},{value:"A* Path Planning Algorithm",id:"a-path-planning-algorithm",level:4},{value:"Dynamic Path Replanning",id:"dynamic-path-replanning",level:4},{value:"2. Local Path Planning and Control",id:"2-local-path-planning-and-control",level:3},{value:"DWA (Dynamic Window Approach) Controller",id:"dwa-dynamic-window-approach-controller",level:4},{value:"Path Following Controller",id:"path-following-controller",level:4},{value:"3. Costmap and Obstacle Management",id:"3-costmap-and-obstacle-management",level:3},{value:"Costmap Server Implementation",id:"costmap-server-implementation",level:4},{value:"4. Dynamic Obstacle Avoidance",id:"4-dynamic-obstacle-avoidance",level:3},{value:"Obstacle Prediction and Avoidance",id:"obstacle-prediction-and-avoidance",level:4},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Set up Navigation System Infrastructure",id:"step-1-set-up-navigation-system-infrastructure",level:3},{value:"Step 2: Configure Navigation Parameters",id:"step-2-configure-navigation-parameters",level:3},{value:"Step 3: Implement Recovery Behaviors",id:"step-3-implement-recovery-behaviors",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Unit Testing",id:"unit-testing",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:2},{value:"Navigation Performance",id:"navigation-performance",level:3},{value:"Accuracy Requirements",id:"accuracy-requirements",level:3},{value:"Troubleshooting and Common Issues",id:"troubleshooting-and-common-issues",level:2},{value:"Path Planning Problems",id:"path-planning-problems",level:3},{value:"Control Problems",id:"control-problems",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Next Steps and Integration",id:"next-steps-and-integration",level:2},{value:"Integration with Other Capstone Components",id:"integration-with-other-capstone-components",level:3},{value:"Advanced Features",id:"advanced-features",level:3},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"navigation-and-obstacle-avoidance-autonomous-humanoid-capstone",children:"Navigation and Obstacle Avoidance: Autonomous Humanoid Capstone"})}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Navigation and obstacle avoidance form the mobility foundation of the autonomous humanoid system, enabling safe and efficient movement through complex environments. This component encompasses path planning, localization, obstacle detection, dynamic obstacle avoidance, and recovery from navigation failures. The system must handle both static obstacles in known environments and dynamic obstacles that appear during navigation, while maintaining real-time performance and safety guarantees."}),"\n",(0,a.jsx)(e.p,{children:"The navigation system integrates with task planning to execute mobility goals, with perception for environmental awareness, with manipulation for precise positioning, and with voice processing for location-based commands. This implementation guide provides detailed instructions for building a robust navigation and obstacle avoidance system that can operate in real-world environments with varying complexity."}),"\n",(0,a.jsx)(e.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"navigation-stack-architecture",children:"Navigation Stack Architecture"}),"\n",(0,a.jsx)(e.p,{children:"The navigation system implements a layered architecture following ROS 2 Navigation2 standards:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"High-Level Goals \u2192 Path Planning \u2192 Path Following \u2192 Local Control \u2192 Robot Motion\n"})}),"\n",(0,a.jsx)(e.p,{children:"The architecture consists of:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Global Planner"}),": Computes optimal paths in static map"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Local Planner"}),": Generates velocity commands for immediate motion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Costmap Server"}),": Maintains obstacle information"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Controller Server"}),": Follows reference paths with velocity control"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery Server"}),": Handles navigation failures with recovery behaviors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lifecycle Manager"}),": Manages navigation lifecycle states"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"integration-with-other-systems",children:"Integration with Other Systems"}),"\n",(0,a.jsx)(e.p,{children:"The navigation system interfaces with:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task Planning"}),": Receives navigation goals and reports completion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Perception System"}),": Gets real-time obstacle information"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Localization"}),": Maintains accurate position estimate"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Manipulation"}),": Provides precise positioning for object interaction"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Voice Processing"}),": Handles location-based commands"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,a.jsx)(e.h3,{id:"1-global-path-planning",children:"1. Global Path Planning"}),"\n",(0,a.jsx)(e.h4,{id:"a-path-planning-algorithm",children:"A* Path Planning Algorithm"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import heapq\r\nimport numpy as np\r\nfrom typing import List, Tuple, Dict, Optional\r\nimport rospy\r\n\r\nclass GridMap:\r\n    """Represents the navigation environment as a grid"""\r\n\r\n    def __init__(self, width: int, height: int, resolution: float = 0.05):\r\n        self.width = width\r\n        self.height = height\r\n        self.resolution = resolution\r\n        self.grid = np.zeros((height, width), dtype=np.uint8)  # 0: free, 255: occupied\r\n\r\n    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:\r\n        """Convert world coordinates to grid coordinates"""\r\n        grid_x = int((x - self.resolution * self.width / 2) / self.resolution)\r\n        grid_y = int((y - self.resolution * self.height / 2) / self.resolution)\r\n        return grid_x, grid_y\r\n\r\n    def grid_to_world(self, grid_x: int, grid_y: int) -> Tuple[float, float]:\r\n        """Convert grid coordinates to world coordinates"""\r\n        x = grid_x * self.resolution + self.resolution * self.width / 2\r\n        y = grid_y * self.resolution + self.resolution * self.height / 2\r\n        return x, y\r\n\r\n    def is_valid(self, x: int, y: int) -> bool:\r\n        """Check if grid coordinates are within bounds and free"""\r\n        return (0 <= x < self.width and\r\n                0 <= y < self.height and\r\n                self.grid[y, x] < 127)  # Consider values < 127 as free space\r\n\r\n    def get_neighbors(self, x: int, y: int) -> List[Tuple[int, int]]:\r\n        """Get valid neighboring cells (8-connectivity)"""\r\n        neighbors = []\r\n        for dx in [-1, 0, 1]:\r\n            for dy in [-1, 0, 1]:\r\n                if dx == 0 and dy == 0:\r\n                    continue\r\n                nx, ny = x + dx, y + dy\r\n                if self.is_valid(nx, ny):\r\n                    neighbors.append((nx, ny))\r\n        return neighbors\r\n\r\nclass AStarPlanner:\r\n    """A* path planning algorithm implementation"""\r\n\r\n    def __init__(self, grid_map: GridMap):\r\n        self.grid_map = grid_map\r\n        self.diagonal_cost = np.sqrt(2)\r\n\r\n    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\r\n        """Calculate heuristic distance (Euclidean)"""\r\n        dx = pos1[0] - pos2[0]\r\n        dy = pos1[1] - pos2[1]\r\n        return np.sqrt(dx*dx + dy*dy)\r\n\r\n    def plan(self, start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:\r\n        """Plan path from start to goal using A* algorithm"""\r\n        open_set = [(0, start)]\r\n        came_from = {}\r\n        g_score = {start: 0}\r\n        f_score = {start: self.heuristic(start, goal)}\r\n\r\n        while open_set:\r\n            current = heapq.heappop(open_set)[1]\r\n\r\n            if current == goal:\r\n                # Reconstruct path\r\n                path = [current]\r\n                while current in came_from:\r\n                    current = came_from[current]\r\n                    path.append(current)\r\n                path.reverse()\r\n                return path\r\n\r\n            for neighbor in self.grid_map.get_neighbors(*current):\r\n                tentative_g_score = g_score[current] + self._get_distance(current, neighbor)\r\n\r\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\r\n                    came_from[neighbor] = current\r\n                    g_score[neighbor] = tentative_g_score\r\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)\r\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\r\n\r\n        return None  # No path found\r\n\r\n    def _get_distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\r\n        """Calculate distance between adjacent grid cells"""\r\n        dx = abs(pos1[0] - pos2[0])\r\n        dy = abs(pos1[1] - pos2[1])\r\n\r\n        if dx == 1 and dy == 1:  # Diagonal\r\n            return self.diagonal_cost\r\n        else:  # Horizontal/Vertical\r\n            return 1.0\r\n\r\nclass GlobalPlanner:\r\n    """Global path planner interface for navigation system"""\r\n\r\n    def __init__(self):\r\n        self.grid_map = None\r\n        self.planner = None\r\n        self.path_cache = {}\r\n\r\n    def set_map(self, occupancy_grid):\r\n        """Set the global map for planning"""\r\n        # Convert ROS OccupancyGrid to internal GridMap representation\r\n        width = occupancy_grid.info.width\r\n        height = occupancy_grid.info.height\r\n        resolution = occupancy_grid.info.resolution\r\n\r\n        self.grid_map = GridMap(width, height, resolution)\r\n        self.grid_map.grid = np.array(occupancy_grid.data).reshape((height, width))\r\n\r\n        self.planner = AStarPlanner(self.grid_map)\r\n\r\n    def plan_path(self, start_pose, goal_pose) -> Optional[List[Tuple[float, float]]]:\r\n        """Plan path from start to goal in world coordinates"""\r\n        if not self.planner:\r\n            rospy.logerr("Global map not set")\r\n            return None\r\n\r\n        # Convert world coordinates to grid coordinates\r\n        start_grid = self.grid_map.world_to_grid(start_pose.position.x, start_pose.position.y)\r\n        goal_grid = self.grid_map.world_to_grid(goal_pose.position.x, goal_pose.position.y)\r\n\r\n        # Plan path in grid coordinates\r\n        grid_path = self.planner.plan(start_grid, goal_grid)\r\n\r\n        if not grid_path:\r\n            rospy.logwarn(f"No path found from {start_grid} to {goal_grid}")\r\n            return None\r\n\r\n        # Convert grid path back to world coordinates\r\n        world_path = []\r\n        for grid_x, grid_y in grid_path:\r\n            world_x, world_y = self.grid_map.grid_to_world(grid_x, grid_y)\r\n            world_path.append((world_x, world_y))\r\n\r\n        return world_path\n'})}),"\n",(0,a.jsx)(e.h4,{id:"dynamic-path-replanning",children:"Dynamic Path Replanning"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class DynamicPlanner:\r\n    """Handles dynamic replanning when obstacles are detected"""\r\n\r\n    def __init__(self, global_planner: GlobalPlanner):\r\n        self.global_planner = global_planner\r\n        self.current_path = []\r\n        self.path_index = 0\r\n        self.replan_threshold = 0.5  # meters\r\n\r\n    def update_obstacles(self, obstacle_map):\r\n        """Update obstacle information and replan if necessary"""\r\n        # Check if current path is blocked by new obstacles\r\n        if self._is_path_blocked(self.current_path[self.path_index:], obstacle_map):\r\n            # Replan from current position\r\n            current_pos = self.get_current_position()\r\n            goal_pos = self.get_goal_position()\r\n\r\n            new_path = self.global_planner.plan_path(current_pos, goal_pos)\r\n            if new_path:\r\n                self.current_path = new_path\r\n                self.path_index = 0\r\n                return True\r\n\r\n        return False\r\n\r\n    def _is_path_blocked(self, path: List[Tuple[float, float]], obstacle_map) -> bool:\r\n        """Check if path is blocked by obstacles"""\r\n        # This would check each point in path against obstacle map\r\n        for point in path:\r\n            if self._is_point_blocked(point, obstacle_map):\r\n                return True\r\n        return False\r\n\r\n    def _is_point_blocked(self, point: Tuple[float, float], obstacle_map) -> bool:\r\n        """Check if a single point is blocked by obstacles"""\r\n        # Simplified check - in practice this would query costmap\r\n        return False  # Placeholder implementation\r\n\r\n    def get_current_position(self):\r\n        """Get current robot position from localization"""\r\n        # This would interface with localization system\r\n        pass\r\n\r\n    def get_goal_position(self):\r\n        """Get current navigation goal"""\r\n        # This would return the current goal\r\n        pass\n'})}),"\n",(0,a.jsx)(e.h3,{id:"2-local-path-planning-and-control",children:"2. Local Path Planning and Control"}),"\n",(0,a.jsx)(e.h4,{id:"dwa-dynamic-window-approach-controller",children:"DWA (Dynamic Window Approach) Controller"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from dataclasses import dataclass\r\nfrom geometry_msgs.msg import Twist, Pose, Point\r\nimport math\r\n\r\n@dataclass\r\nclass RobotState:\r\n    """Current robot state for local planning"""\r\n    x: float = 0.0\r\n    y: float = 0.0\r\n    theta: float = 0.0\r\n    vx: float = 0.0\r\n    vy: float = 0.0\r\n    vtheta: float = 0.0\r\n\r\n@dataclass\r\nclass RobotConfig:\r\n    """Robot configuration parameters"""\r\n    max_speed_linear: float = 0.5\r\n    max_speed_angular: float = 1.0\r\n    min_speed_linear: float = 0.05\r\n    min_speed_angular: float = 0.1\r\n    max_accel_linear: float = 1.0\r\n    max_accel_angular: float = 2.0\r\n    robot_radius: float = 0.3\r\n    dt: float = 0.1\r\n\r\nclass DWAController:\r\n    """Dynamic Window Approach local planner"""\r\n\r\n    def __init__(self, config: RobotConfig):\r\n        self.config = config\r\n        self.robot_state = RobotState()\r\n\r\n    def get_dynamic_window(self) -> Tuple[float, float, float, float]:\r\n        """Calculate dynamic window based on current velocities and constraints"""\r\n        vs_min = max(-self.config.max_speed_linear,\r\n                    self.robot_state.vx - self.config.max_accel_linear * self.config.dt)\r\n        vs_max = min(self.config.max_speed_linear,\r\n                    self.robot_state.vx + self.config.max_accel_linear * self.config.dt)\r\n\r\n        ws_min = max(-self.config.max_speed_angular,\r\n                    self.robot_state.vtheta - self.config.max_accel_angular * self.config.dt)\r\n        ws_max = min(self.config.max_speed_angular,\r\n                    self.robot_state.vtheta + self.config.max_accel_angular * self.config.dt)\r\n\r\n        return vs_min, vs_max, ws_min, ws_max\r\n\r\n    def predict_trajectory(self, v: float, w: float, predict_time: float = 1.0) -> List[Tuple[float, float]]:\r\n        """Predict trajectory for given velocity commands"""\r\n        trajectory = []\r\n        state = RobotState(\r\n            x=self.robot_state.x,\r\n            y=self.robot_state.y,\r\n            theta=self.robot_state.theta,\r\n            vx=self.robot_state.vx,\r\n            vy=self.robot_state.vy,\r\n            vtheta=self.robot_state.vtheta\r\n        )\r\n\r\n        dt = self.config.dt\r\n        time = 0.0\r\n\r\n        while time < predict_time:\r\n            # Update state based on velocity commands\r\n            state.x += v * math.cos(state.theta) * dt\r\n            state.y += v * math.sin(state.theta) * dt\r\n            state.theta += w * dt\r\n            state.vx = v\r\n            state.vtheta = w\r\n\r\n            trajectory.append((state.x, state.y))\r\n            time += dt\r\n\r\n        return trajectory\r\n\r\n    def calc_to_goal_cost(self, trajectory: List[Tuple[float, float]], goal: Tuple[float, float]) -> float:\r\n        """Calculate cost to goal for trajectory"""\r\n        last_point = trajectory[-1] if trajectory else (0, 0)\r\n        distance = math.sqrt((last_point[0] - goal[0])**2 + (last_point[1] - goal[1])**2)\r\n        return distance\r\n\r\n    def calc_obstacle_cost(self, trajectory: List[Tuple[float, float]], obstacles: List[Tuple[float, float]]) -> float:\r\n        """Calculate obstacle collision cost for trajectory"""\r\n        if not trajectory:\r\n            return float(\'inf\')\r\n\r\n        min_dist = float(\'inf\')\r\n        for point in trajectory:\r\n            for obs in obstacles:\r\n                dist = math.sqrt((point[0] - obs[0])**2 + (point[1] - obs[1])**2)\r\n                if dist < min_dist:\r\n                    min_dist = dist\r\n\r\n        # Return high cost if too close to obstacles\r\n        if min_dist < self.config.robot_radius:\r\n            return float(\'inf\')\r\n        else:\r\n            return 1.0 / min_dist if min_dist > 0 else float(\'inf\')\r\n\r\n    def dwa_control(self, goal: Tuple[float, float], obstacles: List[Tuple[float, float]]) -> Tuple[float, float]:\r\n        """Calculate optimal velocity commands using DWA"""\r\n        vs_min, vs_max, ws_min, ws_max = self.get_dynamic_window()\r\n\r\n        best_v = 0.0\r\n        best_w = 0.0\r\n        min_cost = float(\'inf\')\r\n\r\n        # Discretize velocity space\r\n        v_resolution = 0.05\r\n        w_resolution = 0.05\r\n\r\n        v_range = np.arange(vs_min, vs_max, v_resolution)\r\n        w_range = np.arange(ws_min, ws_max, w_resolution)\r\n\r\n        for v in v_range:\r\n            for w in w_range:\r\n                trajectory = self.predict_trajectory(v, w)\r\n\r\n                # Calculate costs\r\n                to_goal_cost = self.calc_to_goal_cost(trajectory, goal)\r\n                obstacle_cost = self.calc_obstacle_cost(trajectory, obstacles)\r\n\r\n                # Combine costs with weights\r\n                # Higher weights mean more important\r\n                alpha = 1.0  # Goal heading cost weight\r\n                beta = 1.0   # Velocity cost weight\r\n                gamma = 1.0  # Obstacle cost weight\r\n\r\n                cost = alpha * to_goal_cost + gamma * obstacle_cost\r\n\r\n                if cost < min_cost:\r\n                    min_cost = cost\r\n                    best_v = v\r\n                    best_w = w\r\n\r\n        return best_v, best_w\n'})}),"\n",(0,a.jsx)(e.h4,{id:"path-following-controller",children:"Path Following Controller"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class PathFollower:\r\n    """Follows reference path with velocity control"""\r\n\r\n    def __init__(self, config: RobotConfig):\r\n        self.config = config\r\n        self.path = []\r\n        self.current_index = 0\r\n        self.lookahead_distance = 0.5\r\n        self.kp_linear = 1.0\r\n        self.kp_angular = 2.0\r\n        self.robot_state = RobotState()\r\n\r\n    def set_path(self, path: List[Tuple[float, float]]):\r\n        """Set the reference path to follow"""\r\n        self.path = path\r\n        self.current_index = 0\r\n\r\n    def follow_path(self) -> Twist:\r\n        """Generate velocity commands to follow the path"""\r\n        if not self.path or self.current_index >= len(self.path):\r\n            return Twist()  # Stop if no path or reached goal\r\n\r\n        # Find next target point on path\r\n        target = self._get_target_point()\r\n\r\n        if not target:\r\n            return Twist()\r\n\r\n        # Calculate error\r\n        dx = target[0] - self.robot_state.x\r\n        dy = target[1] - self.robot_state.y\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n        # Calculate desired heading\r\n        desired_theta = math.atan2(dy, dx)\r\n        angle_error = desired_theta - self.robot_state.theta\r\n\r\n        # Normalize angle error\r\n        while angle_error > math.pi:\r\n            angle_error -= 2 * math.pi\r\n        while angle_error < -math.pi:\r\n            angle_error += 2 * math.pi\r\n\r\n        # Generate velocity commands\r\n        cmd = Twist()\r\n\r\n        # Linear velocity: proportional to distance to target, limited by max speed\r\n        cmd.linear.x = min(self.config.max_speed_linear,\r\n                          max(self.config.min_speed_linear,\r\n                              self.kp_linear * distance))\r\n\r\n        # Angular velocity: proportional to angle error, limited by max speed\r\n        cmd.angular.z = min(self.config.max_speed_angular,\r\n                           max(-self.config.max_speed_angular,\r\n                               self.kp_angular * angle_error))\r\n\r\n        # Update path index if close enough to current target\r\n        if distance < 0.1:  # 10cm threshold\r\n            self.current_index += 1\r\n\r\n        return cmd\r\n\r\n    def _get_target_point(self) -> Optional[Tuple[float, float]]:\r\n        """Get the next target point on the path"""\r\n        if self.current_index >= len(self.path):\r\n            return None\r\n\r\n        # Look ahead to find a point at appropriate distance\r\n        current_point = self.path[self.current_index]\r\n\r\n        # Simple approach: take the next point in path\r\n        # For more sophisticated lookahead, see Pure Pursuit algorithms\r\n        target_index = min(self.current_index + 1, len(self.path) - 1)\r\n        return self.path[target_index]\r\n\r\n    def is_goal_reached(self) -> bool:\r\n        """Check if the goal has been reached"""\r\n        if not self.path:\r\n            return True\r\n\r\n        goal = self.path[-1]\r\n        distance = math.sqrt((self.robot_state.x - goal[0])**2 + (self.robot_state.y - goal[1])**2)\r\n        return distance < 0.2  # 20cm tolerance\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-costmap-and-obstacle-management",children:"3. Costmap and Obstacle Management"}),"\n",(0,a.jsx)(e.h4,{id:"costmap-server-implementation",children:"Costmap Server Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class Costmap2D:\r\n    """2D costmap for obstacle representation"""\r\n\r\n    def __init__(self, width: int, height: int, resolution: float, origin_x: float = 0.0, origin_y: float = 0.0):\r\n        self.width = width\r\n        self.height = height\r\n        self.resolution = resolution\r\n        self.origin_x = origin_x\r\n        self.origin_y = origin_y\r\n\r\n        # Initialize costmap with free space (0 = free, 254 = occupied, 255 = unknown)\r\n        self.costmap = np.zeros((height, width), dtype=np.uint8)\r\n\r\n        # Parameters for cost propagation\r\n        self.inflation_radius = 0.5  # meters\r\n        self.cost_scaling_factor = 3.0\r\n\r\n    def world_to_map(self, wx: float, wy: float) -> Tuple[int, int]:\r\n        """Convert world coordinates to map coordinates"""\r\n        mx = int((wx - self.origin_x) / self.resolution)\r\n        my = int((wy - self.origin_y) / self.resolution)\r\n        return mx, my\r\n\r\n    def map_to_world(self, mx: int, my: int) -> Tuple[float, float]:\r\n        """Convert map coordinates to world coordinates"""\r\n        wx = mx * self.resolution + self.origin_x\r\n        wy = my * self.resolution + self.origin_y\r\n        return wx, wy\r\n\r\n    def is_valid_cell(self, mx: int, my: int) -> bool:\r\n        """Check if map coordinates are valid"""\r\n        return 0 <= mx < self.width and 0 <= my < self.height\r\n\r\n    def set_obstacle(self, wx: float, wy: float, cost: int = 254):\r\n        """Set obstacle at world coordinates"""\r\n        mx, my = self.world_to_map(wx, wy)\r\n        if self.is_valid_cell(mx, my):\r\n            self.costmap[my, mx] = min(254, cost)\r\n\r\n    def get_cost(self, wx: float, wy: float) -> int:\r\n        """Get cost at world coordinates"""\r\n        mx, my = self.world_to_map(wx, wy)\r\n        if self.is_valid_cell(mx, my):\r\n            return self.costmap[my, mx]\r\n        else:\r\n            return 255  # Unknown/invalid\r\n\r\n    def update_with_laser_scan(self, laser_data, robot_pose):\r\n        """Update costmap with laser scan data"""\r\n        # Process laser scan to identify obstacles and free space\r\n        angle_min = laser_data.angle_min\r\n        angle_increment = laser_data.angle_increment\r\n\r\n        for i, range_val in enumerate(laser_data.ranges):\r\n            if not (laser_data.range_min <= range_val <= laser_data.range_max):\r\n                continue  # Invalid range\r\n\r\n            # Calculate angle of this range measurement\r\n            angle = angle_min + i * angle_increment\r\n\r\n            # Calculate world coordinates of obstacle\r\n            ox = robot_pose.position.x + range_val * math.cos(robot_pose.orientation.z + angle)\r\n            oy = robot_pose.position.y + range_val * math.sin(robot_pose.orientation.z + angle)\r\n\r\n            # Set obstacle in costmap\r\n            self.set_obstacle(ox, oy)\r\n\r\n    def update_with_occupancy_grid(self, occupancy_grid):\r\n        """Update costmap with occupancy grid data"""\r\n        # This would merge the incoming occupancy grid with current costmap\r\n        # For now, we\'ll do a simple copy if the grids match in size and resolution\r\n        pass\r\n\r\n    def inflate_obstacles(self):\r\n        """Inflate obstacles to create safety margins"""\r\n        # Create a copy of the original costmap\r\n        original_costmap = self.costmap.copy()\r\n\r\n        # Calculate inflation radius in cells\r\n        inflation_cells = int(self.inflation_radius / self.resolution)\r\n\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if original_costmap[y, x] >= 254:  # Obstacle cell\r\n                    # Inflate obstacle in a circular pattern\r\n                    for dy in range(-inflation_cells, inflation_cells + 1):\r\n                        for dx in range(-inflation_cells, inflation_cells + 1):\r\n                            nx, ny = x + dx, y + dy\r\n\r\n                            if self.is_valid_cell(nx, ny):\r\n                                # Calculate distance from obstacle center\r\n                                dist = math.sqrt(dx*dx + dy*dy) * self.resolution\r\n\r\n                                if dist <= self.inflation_radius:\r\n                                    # Calculate cost based on distance (higher cost closer to obstacle)\r\n                                    cost = int(254 * (1.0 - dist / self.inflation_radius))\r\n                                    self.costmap[ny, nx] = max(self.costmap[ny, nx], cost)\r\n\r\n    def is_free(self, wx: float, wy: float) -> bool:\r\n        """Check if a point is free for navigation"""\r\n        cost = self.get_cost(wx, wy)\r\n        return cost < 127  # Consider values < 127 as free space\r\n\r\nclass CostmapServer:\r\n    """ROS 2 costmap server interface"""\r\n\r\n    def __init__(self):\r\n        self.global_costmap = None\r\n        self.local_costmap = None\r\n        self.update_rate = 10.0  # Hz\r\n        self.transform_tolerance = 0.1  # seconds\r\n\r\n        # Initialize costmaps\r\n        self._initialize_costmaps()\r\n\r\n        # ROS interfaces\r\n        self.laser_sub = rospy.Subscriber(\'/scan\', LaserScan, self.laser_callback)\r\n        self.map_sub = rospy.Subscriber(\'/map\', OccupancyGrid, self.map_callback)\r\n        self.odom_sub = rospy.Subscriber(\'/odom\', Odometry, self.odom_callback)\r\n\r\n    def _initialize_costmaps(self):\r\n        """Initialize global and local costmaps"""\r\n        # In practice, these would be configured based on map and robot parameters\r\n        map_width = 100  # cells\r\n        map_height = 100  # cells\r\n        resolution = 0.05  # meters per cell\r\n\r\n        self.global_costmap = Costmap2D(map_width, map_height, resolution)\r\n        self.local_costmap = Costmap2D(50, 50, resolution)  # Smaller local map\r\n\r\n    def laser_callback(self, msg):\r\n        """Handle incoming laser scan data"""\r\n        if self.local_costmap:\r\n            # Update local costmap with laser data\r\n            robot_pose = self.get_robot_pose()\r\n            self.local_costmap.update_with_laser_scan(msg, robot_pose)\r\n            self.local_costmap.inflate_obstacles()\r\n\r\n    def map_callback(self, msg):\r\n        """Handle incoming map data"""\r\n        if self.global_costmap:\r\n            # Update global costmap with new map\r\n            self.global_costmap.update_with_occupancy_grid(msg)\r\n\r\n    def odom_callback(self, msg):\r\n        """Handle odometry updates"""\r\n        # Update robot pose for costmap operations\r\n        pass\r\n\r\n    def get_robot_pose(self):\r\n        """Get current robot pose"""\r\n        # This would interface with TF or localization system\r\n        pass\r\n\r\n    def get_cost_at_point(self, frame_id: str, x: float, y: float) -> int:\r\n        """Get cost at specific point in specified frame"""\r\n        # Transform point to costmap frame and query cost\r\n        if frame_id == \'map\':\r\n            return self.global_costmap.get_cost(x, y) if self.global_costmap else 255\r\n        elif frame_id == \'base_link\':\r\n            # Transform to map coordinates first\r\n            # This would use TF transform\r\n            return 0  # Placeholder\r\n        else:\r\n            return 255  # Unknown frame\n'})}),"\n",(0,a.jsx)(e.h3,{id:"4-dynamic-obstacle-avoidance",children:"4. Dynamic Obstacle Avoidance"}),"\n",(0,a.jsx)(e.h4,{id:"obstacle-prediction-and-avoidance",children:"Obstacle Prediction and Avoidance"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from collections import deque\r\n\r\nclass ObstacleTracker:\r\n    """Track and predict dynamic obstacles"""\r\n\r\n    def __init__(self):\r\n        self.obstacles = {}  # obstacle_id -> ObstacleTrack\r\n        self.next_id = 0\r\n        self.max_track_length = 20  # Keep last 20 measurements\r\n\r\n    def update_obstacle(self, x: float, y: float, timestamp: float) -> int:\r\n        """Update obstacle position or create new track"""\r\n        # Simple approach: find closest existing obstacle\r\n        closest_id = None\r\n        min_distance = float(\'inf\')\r\n\r\n        for obs_id, track in self.obstacles.items():\r\n            last_pos = track.positions[-1] if track.positions else (0, 0)\r\n            distance = math.sqrt((x - last_pos[0])**2 + (y - last_pos[1])**2)\r\n\r\n            if distance < min_distance and distance < 1.0:  # 1m threshold\r\n                min_distance = distance\r\n                closest_id = obs_id\r\n\r\n        if closest_id is not None:\r\n            # Update existing track\r\n            self.obstacles[closest_id].add_position((x, y), timestamp)\r\n            return closest_id\r\n        else:\r\n            # Create new obstacle track\r\n            obs_id = self.next_id\r\n            self.next_id += 1\r\n            self.obstacles[obs_id] = ObstacleTrack((x, y), timestamp)\r\n            return obs_id\r\n\r\n    def predict_obstacle_motion(self, obs_id: int, time_ahead: float) -> Tuple[float, float]:\r\n        """Predict obstacle position at future time"""\r\n        if obs_id not in self.obstacles:\r\n            return None, None\r\n\r\n        track = self.obstacles[obs_id]\r\n        return track.predict_position(time_ahead)\r\n\r\nclass ObstacleTrack:\r\n    """Track for a single dynamic obstacle"""\r\n\r\n    def __init__(self, initial_pos: Tuple[float, float], timestamp: float):\r\n        self.positions = deque(maxlen=20)  # Keep last 20 positions\r\n        self.timestamps = deque(maxlen=20)  # Keep corresponding timestamps\r\n        self.positions.append(initial_pos)\r\n        self.timestamps.append(timestamp)\r\n\r\n    def add_position(self, pos: Tuple[float, float], timestamp: float):\r\n        """Add new position measurement"""\r\n        self.positions.append(pos)\r\n        self.timestamps.append(timestamp)\r\n\r\n    def predict_position(self, time_ahead: float) -> Tuple[float, float]:\r\n        """Predict position time_ahead seconds into the future"""\r\n        if len(self.positions) < 2:\r\n            # Not enough data for prediction, return current position\r\n            return self.positions[-1] if self.positions else (0, 0)\r\n\r\n        # Calculate average velocity from recent positions\r\n        pos1 = self.positions[-2]\r\n        pos2 = self.positions[-1]\r\n        time1 = self.timestamps[-2]\r\n        time2 = self.timestamps[-1]\r\n\r\n        dt = time2 - time1\r\n        if dt <= 0:\r\n            return pos2\r\n\r\n        vx = (pos2[0] - pos1[0]) / dt\r\n        vy = (pos2[1] - pos1[1]) / dt\r\n\r\n        # Predict future position\r\n        predicted_x = pos2[0] + vx * time_ahead\r\n        predicted_y = pos2[1] + vy * time_ahead\r\n\r\n        return (predicted_x, predicted_y)\r\n\r\nclass DynamicAvoidance:\r\n    """Handle dynamic obstacle avoidance"""\r\n\r\n    def __init__(self, config: RobotConfig):\r\n        self.config = config\r\n        self.obstacle_tracker = ObstacleTracker()\r\n        self.safe_distance = 0.8  # meters\r\n        self.avoidance_active = False\r\n\r\n    def update_obstacles(self, obstacle_positions: List[Tuple[float, float]], timestamp: float):\r\n        """Update with new obstacle detections"""\r\n        for pos in obstacle_positions:\r\n            self.obstacle_tracker.update_obstacle(pos[0], pos[1], timestamp)\r\n\r\n    def calculate_avoidance_command(self, robot_state: RobotState) -> Optional[Twist]:\r\n        """Calculate avoidance velocity command if needed"""\r\n        # Check for obstacles in robot\'s path\r\n        for obs_id in list(self.obstacle_tracker.obstacles.keys()):\r\n            predicted_pos = self.obstacle_tracker.predict_obstacle_motion(obs_id, 0.5)  # 0.5 sec prediction\r\n\r\n            if predicted_pos:\r\n                distance = math.sqrt((predicted_pos[0] - robot_state.x)**2 +\r\n                                   (predicted_pos[1] - robot_state.y)**2)\r\n\r\n                if distance < self.safe_distance:\r\n                    # Obstacle is too close, calculate avoidance command\r\n                    return self._calculate_evasion_command(robot_state, predicted_pos)\r\n\r\n        return None  # No avoidance needed\r\n\r\n    def _calculate_evasion_command(self, robot_state: RobotState, obstacle_pos: Tuple[float, float]) -> Twist:\r\n        """Calculate command to avoid obstacle"""\r\n        cmd = Twist()\r\n\r\n        # Calculate direction away from obstacle\r\n        dx = robot_state.x - obstacle_pos[0]\r\n        dy = robot_state.y - obstacle_pos[1]\r\n\r\n        # Normalize direction vector\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n        if distance > 0:\r\n            dx /= distance\r\n            dy /= distance\r\n\r\n        # Calculate evasion direction (perpendicular to obstacle direction)\r\n        evasion_x = -dy  # Rotate 90 degrees\r\n        evasion_y = dx\r\n\r\n        # Set linear velocity to move away while maintaining forward progress\r\n        cmd.linear.x = max(0.1, min(self.config.max_speed_linear * 0.3,\r\n                                   self.config.max_speed_linear * 0.5))\r\n\r\n        # Set angular velocity to turn away from obstacle\r\n        target_angle = math.atan2(evasion_y, evasion_x)\r\n        current_angle = robot_state.theta\r\n        angle_error = target_angle - current_angle\r\n\r\n        # Normalize angle error\r\n        while angle_error > math.pi:\r\n            angle_error -= 2 * math.pi\r\n        while angle_error < -math.pi:\r\n            angle_error += 2 * math.pi\r\n\r\n        cmd.angular.z = max(-self.config.max_speed_angular * 0.8,\r\n                           min(self.config.max_speed_angular * 0.8,\r\n                               angle_error * 2.0))\r\n\r\n        return cmd\n'})}),"\n",(0,a.jsx)(e.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,a.jsx)(e.h3,{id:"step-1-set-up-navigation-system-infrastructure",children:"Step 1: Set up Navigation System Infrastructure"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Create the main navigation node:"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport rospy\r\nfrom nav_msgs.msg import Path, Odometry\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom std_msgs.msg import String\r\n\r\nclass NavigationServer:\r\n    def __init__(self):\r\n        rospy.init_node(\'navigation_server\')\r\n\r\n        # Initialize components\r\n        self.config = RobotConfig()\r\n        self.global_planner = GlobalPlanner()\r\n        self.local_planner = DWAController(self.config)\r\n        self.path_follower = PathFollower(self.config)\r\n        self.costmap_server = CostmapServer()\r\n        self.dynamic_avoidance = DynamicAvoidance(self.config)\r\n\r\n        # State variables\r\n        self.current_goal = None\r\n        self.current_path = []\r\n        self.navigation_active = False\r\n        self.robot_state = RobotState()\r\n\r\n        # Publishers and subscribers\r\n        self.cmd_vel_pub = rospy.Publisher(\'/cmd_vel\', Twist, queue_size=10)\r\n        self.path_pub = rospy.Publisher(\'/current_path\', Path, queue_size=10)\r\n        self.goal_sub = rospy.Subscriber(\'/move_base_simple/goal\', PoseStamped, self.goal_callback)\r\n        self.odom_sub = rospy.Subscriber(\'/odom\', Odometry, self.odom_callback)\r\n        self.laser_sub = rospy.Subscriber(\'/scan\', LaserScan, self.laser_callback)\r\n\r\n        rospy.loginfo("Navigation server initialized")\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle incoming navigation goal"""\r\n        rospy.loginfo(f"Received navigation goal: ({msg.pose.position.x}, {msg.pose.position.y})")\r\n\r\n        # Plan path to goal\r\n        start_pose = self.get_current_pose()\r\n        self.current_path = self.global_planner.plan_path(start_pose, msg.pose)\r\n\r\n        if self.current_path:\r\n            # Set the path for following\r\n            self.path_follower.set_path(self.current_path)\r\n            self.current_goal = (msg.pose.position.x, msg.pose.position.y)\r\n            self.navigation_active = True\r\n\r\n            # Publish the planned path\r\n            self._publish_path()\r\n\r\n            rospy.loginfo(f"Planned path with {len(self.current_path)} waypoints")\r\n        else:\r\n            rospy.logerr("Failed to plan path to goal")\r\n\r\n    def odom_callback(self, msg):\r\n        """Update robot state from odometry"""\r\n        self.robot_state.x = msg.pose.pose.position.x\r\n        self.robot_state.y = msg.pose.pose.position.y\r\n\r\n        # Convert quaternion to euler for theta\r\n        orientation = msg.pose.pose.orientation\r\n        self.robot_state.theta = math.atan2(2*(orientation.w*orientation.z + orientation.x*orientation.y),\r\n                                           1 - 2*(orientation.y*orientation.y + orientation.z*orientation.z))\r\n\r\n        self.robot_state.vx = msg.twist.twist.linear.x\r\n        self.robot_state.vy = msg.twist.twist.linear.y\r\n        self.robot_state.vtheta = msg.twist.twist.angular.z\r\n\r\n    def laser_callback(self, msg):\r\n        """Handle laser scan for obstacle detection"""\r\n        # Process laser scan to identify obstacles\r\n        obstacles = self._extract_obstacles_from_scan(msg)\r\n        self.dynamic_avoidance.update_obstacles(obstacles, rospy.get_time())\r\n\r\n    def _extract_obstacles_from_scan(self, scan_msg) -> List[Tuple[float, float]]:\r\n        """Extract obstacle positions from laser scan"""\r\n        obstacles = []\r\n        angle_min = scan_msg.angle_min\r\n        angle_increment = scan_msg.angle_increment\r\n\r\n        for i, range_val in enumerate(scan_msg.ranges):\r\n            if scan_msg.range_min <= range_val <= scan_msg.range_max:\r\n                angle = angle_min + i * angle_increment\r\n                # Convert to world coordinates relative to robot\r\n                x = range_val * math.cos(angle) + self.robot_state.x\r\n                y = range_val * math.sin(angle) + self.robot_state.y\r\n                obstacles.append((x, y))\r\n\r\n        return obstacles\r\n\r\n    def get_current_pose(self):\r\n        """Get current robot pose (simplified)"""\r\n        # This would interface with localization system\r\n        pose = Pose()\r\n        pose.position.x = self.robot_state.x\r\n        pose.position.y = self.robot_state.y\r\n        # Set orientation from theta\r\n        pose.orientation.z = math.sin(self.robot_state.theta / 2)\r\n        pose.orientation.w = math.cos(self.robot_state.theta / 2)\r\n        return pose\r\n\r\n    def execute_navigation(self):\r\n        """Main navigation execution logic"""\r\n        if not self.navigation_active or not self.current_path:\r\n            return\r\n\r\n        # Check if goal is reached\r\n        if self.path_follower.is_goal_reached():\r\n            self._navigation_complete()\r\n            return\r\n\r\n        # Check for dynamic obstacles requiring avoidance\r\n        avoidance_cmd = self.dynamic_avoidance.calculate_avoidance_command(self.robot_state)\r\n\r\n        if avoidance_cmd:\r\n            # Execute avoidance maneuver\r\n            self.cmd_vel_pub.publish(avoidance_cmd)\r\n        else:\r\n            # Follow planned path\r\n            cmd = self.path_follower.follow_path()\r\n            self.cmd_vel_pub.publish(cmd)\r\n\r\n    def _navigation_complete(self):\r\n        """Handle navigation completion"""\r\n        rospy.loginfo("Navigation goal reached")\r\n        self.navigation_active = False\r\n        self.current_path = []\r\n        self.current_goal = None\r\n\r\n        # Publish completion status\r\n        status_pub = rospy.Publisher(\'/navigation_status\', String, queue_size=1, latch=True)\r\n        status_pub.publish("GOAL_REACHED")\r\n\r\n    def _publish_path(self):\r\n        """Publish the current path for visualization"""\r\n        if not self.current_path:\r\n            return\r\n\r\n        path_msg = Path()\r\n        path_msg.header.frame_id = "map"\r\n        path_msg.header.stamp = rospy.Time.now()\r\n\r\n        for i, (x, y) in enumerate(self.current_path):\r\n            pose = PoseStamped()\r\n            pose.header.seq = i\r\n            pose.header.stamp = rospy.Time.now()\r\n            pose.header.frame_id = "map"\r\n            pose.pose.position.x = x\r\n            pose.pose.position.y = y\r\n            pose.pose.position.z = 0.0\r\n            path_msg.poses.append(pose)\r\n\r\n        self.path_pub.publish(path_msg)\r\n\r\n    def run(self):\r\n        """Main execution loop"""\r\n        rate = rospy.Rate(20)  # 20 Hz navigation loop\r\n\r\n        while not rospy.is_shutdown():\r\n            if self.navigation_active:\r\n                self.execute_navigation()\r\n\r\n            rate.sleep()\r\n\r\nif __name__ == \'__main__\':\r\n    nav_server = NavigationServer()\r\n    try:\r\n        nav_server.run()\r\n    except rospy.ROSInterruptException:\r\n        pass\n'})}),"\n",(0,a.jsx)(e.h3,{id:"step-2-configure-navigation-parameters",children:"Step 2: Configure Navigation Parameters"}),"\n",(0,a.jsx)(e.p,{children:"Create a configuration file for navigation parameters:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'# navigation_params.yaml\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    planner_plugins: ["GridBased"]\r\n    GridBased.type: "nav2_navfn_planner/NavfnPlanner"\r\n    GridBased:\r\n      tolerance: 0.5\r\n      use_astar: false\r\n      allow_unknown: true\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.5\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.1\r\n    controller_plugins: ["FollowPath"]\r\n    FollowPath.type: "nav2_rotation_shim_controller/RotationShimController"\r\n    FollowPath:\r\n      velocity_deadband: 0.05\r\n      simulate_ahead_time: 1.0\r\n      max_linear_accel: 2.5\r\n      max_linear_decel: 2.5\r\n      max_angular_accel: 3.2\r\n      max_angular_decel: 3.2\r\n      transform_tolerance: 0.1\r\n      min_local_plan_length: 0.5\r\n      lookahead:\r\n        min_distance: 0.3\r\n        max_distance: 0.6\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 5.0\r\n      publish_frequency: 2.0\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      use_sim_time: true\r\n      rolling_window: true\r\n      width: 3\r\n      height: 3\r\n      resolution: 0.05\r\n      origin_x: -1.5\r\n      origin_y: -1.5\r\n      plugins: ["voxel_layer", "inflation_layer"]\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\r\n\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      use_sim_time: true\r\n      width: 100\r\n      height: 100\r\n      resolution: 0.05\r\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\n'})}),"\n",(0,a.jsx)(e.h3,{id:"step-3-implement-recovery-behaviors",children:"Step 3: Implement Recovery Behaviors"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class RecoveryBehaviors:\r\n    """Implement navigation recovery behaviors"""\r\n\r\n    def __init__(self, config: RobotConfig):\r\n        self.config = config\r\n        self.current_behavior = None\r\n        self.behavior_start_time = 0.0\r\n\r\n    def attempt_recovery(self, recovery_type: str) -> bool:\r\n        """Attempt specified recovery behavior"""\r\n        rospy.loginfo(f"Attempting recovery: {recovery_type}")\r\n\r\n        self.current_behavior = recovery_type\r\n        self.behavior_start_time = rospy.get_time()\r\n\r\n        if recovery_type == "spin":\r\n            return self._spin_recovery()\r\n        elif recovery_type == "backup":\r\n            return self._backup_recovery()\r\n        elif recovery_type == "dodge":\r\n            return self._dodge_recovery()\r\n        else:\r\n            rospy.logerr(f"Unknown recovery type: {recovery_type}")\r\n            return False\r\n\r\n    def _spin_recovery(self) -> bool:\r\n        """Spin in place to clear local minima"""\r\n        cmd_pub = rospy.Publisher(\'/cmd_vel\', Twist, queue_size=1)\r\n\r\n        cmd = Twist()\r\n        cmd.angular.z = self.config.max_speed_angular * 0.5  # Spin slowly\r\n\r\n        start_time = rospy.get_time()\r\n        timeout = 10.0  # 10 second timeout\r\n\r\n        rate = rospy.Rate(10)\r\n        while (rospy.get_time() - start_time) < timeout and not rospy.is_shutdown():\r\n            cmd_pub.publish(cmd)\r\n            rate.sleep()\r\n\r\n        # Stop spinning\r\n        cmd.angular.z = 0.0\r\n        cmd_pub.publish(cmd)\r\n\r\n        return True\r\n\r\n    def _backup_recovery(self) -> bool:\r\n        """Back up and try different direction"""\r\n        cmd_pub = rospy.Publisher(\'/cmd_vel\', Twist, queue_size=1)\r\n\r\n        cmd = Twist()\r\n        cmd.linear.x = -self.config.max_speed_linear * 0.3  # Back up slowly\r\n\r\n        start_time = rospy.get_time()\r\n        timeout = 5.0  # 5 second backup\r\n\r\n        rate = rospy.Rate(10)\r\n        while (rospy.get_time() - start_time) < timeout and not rospy.is_shutdown():\r\n            cmd_pub.publish(cmd)\r\n            rate.sleep()\r\n\r\n        # Stop backing up\r\n        cmd.linear.x = 0.0\r\n        cmd_pub.publish(cmd)\r\n\r\n        return True\r\n\r\n    def _dodge_recovery(self) -> bool:\r\n        """Attempt to dodge around obstacle"""\r\n        cmd_pub = rospy.Publisher(\'/cmd_vel\', Twist, queue_size=1)\r\n\r\n        # Alternate between left and right dodging\r\n        cmd = Twist()\r\n        cmd.linear.x = self.config.max_speed_linear * 0.2  # Move forward slowly\r\n        cmd.angular.z = self.config.max_speed_angular * 0.3  # Turn right\r\n\r\n        start_time = rospy.get_time()\r\n        timeout = 8.0  # 8 second dodge\r\n\r\n        rate = rospy.Rate(10)\r\n        while (rospy.get_time() - start_time) < timeout and not rospy.is_shutdown():\r\n            cmd_pub.publish(cmd)\r\n\r\n            # Alternate turning direction every 2 seconds\r\n            elapsed = rospy.get_time() - start_time\r\n            if int(elapsed) % 4 < 2:\r\n                cmd.angular.z = self.config.max_speed_angular * 0.3  # Turn right\r\n            else:\r\n                cmd.angular.z = -self.config.max_speed_angular * 0.3  # Turn left\r\n\r\n            rate.sleep()\r\n\r\n        # Stop dodging\r\n        cmd.linear.x = 0.0\r\n        cmd.angular.z = 0.0\r\n        cmd_pub.publish(cmd)\r\n\r\n        return True\n'})}),"\n",(0,a.jsx)(e.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,a.jsx)(e.h3,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import unittest\r\nfrom unittest.mock import Mock, patch\r\n\r\nclass TestAStarPlanner(unittest.TestCase):\r\n    def setUp(self):\r\n        self.grid_map = GridMap(10, 10, 0.1)\r\n        # Add some obstacles to the map\r\n        self.grid_map.grid[5, 5] = 255  # Obstacle in the middle\r\n        self.planner = AStarPlanner(self.grid_map)\r\n\r\n    def test_simple_path(self):\r\n        """Test path planning in free space"""\r\n        path = self.planner.plan((0, 0), (9, 9))\r\n        self.assertIsNotNone(path)\r\n        self.assertGreater(len(path), 0)\r\n\r\n    def test_obstacle_avoidance(self):\r\n        """Test path planning around obstacles"""\r\n        path = self.planner.plan((0, 5), (9, 5))\r\n        self.assertIsNotNone(path)\r\n        # Path should avoid the obstacle at (5, 5)\r\n        obstacle_cells = [(x, 5) for x in range(3, 7)]  # Around obstacle\r\n        path_avoids_obstacle = not any(cell in path for cell in obstacle_cells)\r\n        self.assertTrue(path_avoids_obstacle)\r\n\r\nclass TestDWAController(unittest.TestCase):\r\n    def setUp(self):\r\n        self.config = RobotConfig()\r\n        self.controller = DWAController(self.config)\r\n\r\n    def test_dynamic_window_calculation(self):\r\n        """Test dynamic window calculation"""\r\n        # Set some initial velocity\r\n        self.controller.robot_state.vx = 0.2\r\n        self.controller.robot_state.vtheta = 0.1\r\n\r\n        vs_min, vs_max, ws_min, ws_max = self.controller.get_dynamic_window()\r\n\r\n        # Check that window respects acceleration constraints\r\n        self.assertGreaterEqual(vs_max, 0.2 - self.config.max_accel_linear * self.config.dt)\r\n        self.assertLessEqual(vs_max, 0.2 + self.config.max_accel_linear * self.config.dt)\r\n\r\nclass TestCostmap2D(unittest.TestCase):\r\n    def setUp(self):\r\n        self.costmap = Costmap2D(10, 10, 0.1)\r\n\r\n    def test_obstacle_setting(self):\r\n        """Test setting and getting obstacles"""\r\n        self.costmap.set_obstacle(0.5, 0.5, 200)\r\n        cost = self.costmap.get_cost(0.5, 0.5)\r\n        self.assertEqual(cost, 200)\r\n\r\n    def test_inflation(self):\r\n        """Test obstacle inflation"""\r\n        # Set obstacle in center\r\n        self.costmap.set_obstacle(0.5, 0.5, 254)\r\n        self.costmap.inflate_obstacles()\r\n\r\n        # Check that surrounding cells have increased cost\r\n        surrounding_costs = []\r\n        for dx in [-0.1, 0, 0.1]:\r\n            for dy in [-0.1, 0, 0.1]:\r\n                cost = self.costmap.get_cost(0.5 + dx, 0.5 + dy)\r\n                surrounding_costs.append(cost)\r\n\r\n        # At least some surrounding cells should have cost > 0\r\n        self.assertGreater(sum(c for c in surrounding_costs if c > 0), 0)\r\n\r\nif __name__ == \'__main__\':\r\n    unittest.main()\n'})}),"\n",(0,a.jsx)(e.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class NavigationIntegrationTest:\r\n    def __init__(self):\r\n        rospy.init_node(\'navigation_integration_test\')\r\n        self.nav_server = NavigationServer()\r\n\r\n    def test_navigation_sequence(self):\r\n        """Test complete navigation sequence"""\r\n        # Setup: Define a simple navigation goal\r\n        goal = (2.0, 2.0)  # 2 meters away\r\n\r\n        print("Testing navigation to:", goal)\r\n\r\n        # Simulate receiving a goal (this would normally come from subscriber)\r\n        pose_msg = PoseStamped()\r\n        pose_msg.pose.position.x = goal[0]\r\n        pose_msg.pose.position.y = goal[1]\r\n\r\n        # Trigger goal callback\r\n        self.nav_server.goal_callback(pose_msg)\r\n\r\n        # Simulate execution for a period\r\n        start_time = rospy.get_time()\r\n        timeout = 60.0  # 1 minute timeout\r\n\r\n        while (rospy.get_time() - start_time) < timeout:\r\n            self.nav_server.execute_navigation()\r\n\r\n            if self.nav_server.path_follower.is_goal_reached():\r\n                print("Goal reached successfully!")\r\n                return True\r\n\r\n            rospy.sleep(0.1)\r\n\r\n        print("Navigation timed out")\r\n        return False\n'})}),"\n",(0,a.jsx)(e.h2,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,a.jsx)(e.h3,{id:"navigation-performance",children:"Navigation Performance"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Global Path Planning"}),": < 100ms for typical indoor environments (50x50m)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Local Path Following"}),": < 50ms per control cycle at 20Hz"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Obstacle Detection"}),": < 30ms for laser scan processing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic Avoidance"}),": < 20ms per cycle"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memory Usage"}),": < 50MB for typical operation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"accuracy-requirements",children:"Accuracy Requirements"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Position Accuracy"}),": < 10cm error for static navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Obstacle Detection"}),": > 95% detection rate for obstacles > 20cm"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path Following"}),": < 15cm deviation from planned path"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Goal Reaching"}),": < 20cm tolerance for goal achievement"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting-and-common-issues",children:"Troubleshooting and Common Issues"}),"\n",(0,a.jsx)(e.h3,{id:"path-planning-problems",children:"Path Planning Problems"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"No Path Found"}),": Check map quality and inflation parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Local Minima"}),": Implement more sophisticated global planners"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path Quality"}),": Adjust costmap inflation and planning parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic Replanning"}),": Handle moving obstacles effectively"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"control-problems",children:"Control Problems"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Oscillation"}),": Adjust controller gains and lookahead distances"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision"}),": Increase safety margins and obstacle inflation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Goal Unreachable"}),": Implement proper recovery behaviors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Drift"}),": Improve localization accuracy and frequency"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Conservative Planning"}),": Use appropriate safety margins"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Emergency Stops"}),": Implement immediate stop capabilities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Velocity Limits"}),": Respect safe speed limits for environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Validation"}),": Verify sensor data before acting"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Efficient Algorithms"}),": Use optimized path planning algorithms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Threading"}),": Separate planning and control loops appropriately"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Caching"}),": Cache frequently computed paths when possible"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Adaptive Rates"}),": Adjust update rates based on situation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"maintainability",children:"Maintainability"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Modular Design"}),": Keep path planning, control, and obstacle handling separate"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameter Configuration"}),": Use ROS parameters for easy tuning"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Comprehensive Logging"}),": Log navigation decisions and states"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Testing Framework"}),": Maintain extensive test coverage"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"next-steps-and-integration",children:"Next Steps and Integration"}),"\n",(0,a.jsx)(e.h3,{id:"integration-with-other-capstone-components",children:"Integration with Other Capstone Components"}),"\n",(0,a.jsx)(e.p,{children:"The navigation system integrates with:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task Planning"}),": Receives navigation goals and reports status"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Perception"}),": Gets obstacle information and semantic data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Manipulation"}),": Provides precise positioning for tasks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Localization"}),": Maintains accurate position estimates"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Voice Processing"}),": Handles location-based commands"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,a.jsx)(e.p,{children:"Consider implementing:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multi-floor Navigation"}),": Handle navigation across different levels"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Social Navigation"}),": Respect human navigation patterns"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Learning-based Planning"}),": Adapt to environment-specific patterns"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Predictive Navigation"}),": Anticipate dynamic obstacle movements"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["Continue with ",(0,a.jsx)(e.a,{href:"/Book-ai-native/docs/capstone/object-detection",children:"Object Detection and Manipulation"})," to explore the implementation of the perception and manipulation systems that will enable the robot to interact with objects in its environment."]}),"\n",(0,a.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(e.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453(n,e,r){r.d(e,{R:()=>s,x:()=>i});var t=r(6540);const a={},o=t.createContext(a);function s(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);