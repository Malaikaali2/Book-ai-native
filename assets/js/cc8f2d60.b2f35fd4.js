"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[3799],{8453(r,e,n){n.d(e,{R:()=>a,x:()=>i});var t=n(6540);const o={},s=t.createContext(o);function a(r){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function i(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:a(r.components),t.createElement(s.Provider,{value:e},r.children)}},8499(r,e,n){n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>_,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"capstone/failure-handling","title":"Failure Handling and Status Reporting: Autonomous Humanoid Capstone","description":"Overview","source":"@site/docs/capstone/failure-handling.md","sourceDirName":"capstone","slug":"/capstone/failure-handling","permalink":"/Book-ai-native/docs/capstone/failure-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/capstone/failure-handling.md","tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20},"sidebar":"tutorialSidebar","previous":{"title":"Object Detection and Manipulation: Autonomous Humanoid Capstone","permalink":"/Book-ai-native/docs/capstone/object-detection"},"next":{"title":"End-to-End Integration Guide: Autonomous Humanoid Capstone","permalink":"/Book-ai-native/docs/capstone/integration"}}');var o=n(4848),s=n(8453);const a={sidebar_position:20},i="Failure Handling and Status Reporting: Autonomous Humanoid Capstone",l={},c=[{value:"Overview",id:"overview",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Failure Handling Architecture",id:"failure-handling-architecture",level:3},{value:"Integration with Other Systems",id:"integration-with-other-systems",level:3},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"1. Error Detection and Classification",id:"1-error-detection-and-classification",level:3},{value:"Component Monitoring System",id:"component-monitoring-system",level:4},{value:"Error Classification System",id:"error-classification-system",level:4},{value:"2. Recovery and Graceful Degradation",id:"2-recovery-and-graceful-degradation",level:3},{value:"Recovery Strategy Manager",id:"recovery-strategy-manager",level:4},{value:"Graceful Degradation System",id:"graceful-degradation-system",level:4},{value:"3. Status Reporting and Communication",id:"3-status-reporting-and-communication",level:3},{value:"Status Reporting System",id:"status-reporting-system",level:4},{value:"4. Integration and Coordination",id:"4-integration-and-coordination",level:3},{value:"Failure Handling Coordinator",id:"failure-handling-coordinator",level:4},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Set up Failure Handling Infrastructure",id:"step-1-set-up-failure-handling-infrastructure",level:3},{value:"Step 2: Configure Failure Handling Parameters",id:"step-2-configure-failure-handling-parameters",level:3},{value:"Step 3: Implement Component-Specific Error Handlers",id:"step-3-implement-component-specific-error-handlers",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Unit Testing",id:"unit-testing",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:2},{value:"Failure Handling Performance",id:"failure-handling-performance",level:3},{value:"Reliability Metrics",id:"reliability-metrics",level:3},{value:"Troubleshooting and Common Issues",id:"troubleshooting-and-common-issues",level:2},{value:"Error Detection Problems",id:"error-detection-problems",level:3},{value:"Recovery Problems",id:"recovery-problems",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Next Steps and Integration",id:"next-steps-and-integration",level:2},{value:"Integration with Other Capstone Components",id:"integration-with-other-capstone-components",level:3},{value:"Advanced Features",id:"advanced-features",level:3},{value:"References",id:"references",level:2}];function d(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"failure-handling-and-status-reporting-autonomous-humanoid-capstone",children:"Failure Handling and Status Reporting: Autonomous Humanoid Capstone"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Failure handling and status reporting form the reliability and safety foundation of the autonomous humanoid system, ensuring robust operation in the face of unexpected conditions, system errors, and environmental challenges. This component encompasses error detection, classification, recovery strategies, graceful degradation, and comprehensive status communication to users and other system components. The system must detect failures quickly, respond appropriately to maintain safety, attempt recovery when possible, and provide clear status information to enable effective human oversight."}),"\n",(0,o.jsx)(e.p,{children:"The failure handling system integrates with all other capstone components to monitor their operation, coordinate recovery actions, and maintain overall system stability. This implementation guide provides detailed instructions for building a comprehensive failure handling and status reporting framework that ensures safe and reliable operation of the autonomous humanoid system."}),"\n",(0,o.jsx)(e.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"failure-handling-architecture",children:"Failure Handling Architecture"}),"\n",(0,o.jsx)(e.p,{children:"The failure handling system implements a hierarchical, multi-layered architecture:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Component Monitoring \u2192 Error Detection \u2192 Error Classification \u2192 Recovery Strategy \u2192 Status Reporting\n"})}),"\n",(0,o.jsx)(e.p,{children:"The architecture consists of:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Component Monitors"}),": Monitor individual system components for failures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Error Classifier"}),": Categorize errors by type and severity"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Manager"}),": Execute appropriate recovery strategies"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Safety Handler"}),": Ensure safe system states during failures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Status Reporter"}),": Communicate system status to users and systems"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Logging System"}),": Record all failures and recovery actions"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"integration-with-other-systems",children:"Integration with Other Systems"}),"\n",(0,o.jsx)(e.p,{children:"The failure handling system interfaces with:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"All Capstone Components"}),": Monitors for errors and coordinates recovery"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Navigation System"}),": Handles navigation failures and obstacles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Manipulation System"}),": Manages manipulation errors and object losses"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Perception System"}),": Deals with sensor failures and detection errors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Task Planning"}),": Adjusts plans when failures occur"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Voice Processing"}),": Maintains communication despite errors"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,o.jsx)(e.h3,{id:"1-error-detection-and-classification",children:"1. Error Detection and Classification"}),"\n",(0,o.jsx)(e.h4,{id:"component-monitoring-system",children:"Component Monitoring System"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rospy\r\nimport threading\r\nimport time\r\nfrom enum import Enum\r\nfrom std_msgs.msg import String, Bool\r\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus\r\nfrom collections import defaultdict, deque\r\nimport json\r\n\r\nclass ErrorLevel(Enum):\r\n    DEBUG = 0\r\n    INFO = 1\r\n    WARN = 2\r\n    ERROR = 3\r\n    FATAL = 4\r\n\r\nclass ErrorType(Enum):\r\n    COMMUNICATION = "communication"\r\n    HARDWARE = "hardware"\r\n    SOFTWARE = "software"\r\n    ENVIRONMENTAL = "environmental"\r\n    USER = "user"\r\n    SAFETY = "safety"\r\n\r\nclass ComponentStatus(Enum):\r\n    OK = "ok"\r\n    WARNING = "warning"\r\n    ERROR = "error"\r\n    FATAL = "fatal"\r\n    UNKNOWN = "unknown"\r\n\r\nclass ComponentMonitor:\r\n    """Monitors individual system components for failures"""\r\n\r\n    def __init__(self, component_name: str, timeout: float = 5.0):\r\n        self.component_name = component_name\r\n        self.timeout = timeout\r\n        self.last_heartbeat = rospy.get_time()\r\n        self.status = ComponentStatus.OK\r\n        self.error_history = deque(maxlen=100)  # Keep last 100 errors\r\n        self.monitoring_active = True\r\n        self.lock = threading.Lock()\r\n\r\n    def heartbeat(self):\r\n        """Update component heartbeat timestamp"""\r\n        with self.lock:\r\n            self.last_heartbeat = rospy.get_time()\r\n            if self.status != ComponentStatus.FATAL:\r\n                self.status = ComponentStatus.OK\r\n\r\n    def report_error(self, error_msg: str, error_level: ErrorLevel, error_type: ErrorType):\r\n        """Report an error from this component"""\r\n        with self.lock:\r\n            error_record = {\r\n                \'timestamp\': rospy.get_time(),\r\n                \'message\': error_msg,\r\n                \'level\': error_level,\r\n                \'type\': error_type,\r\n                \'component\': self.component_name\r\n            }\r\n            self.error_history.append(error_record)\r\n\r\n            # Update component status based on error level\r\n            if error_level == ErrorLevel.FATAL:\r\n                self.status = ComponentStatus.FATAL\r\n            elif error_level == ErrorLevel.ERROR:\r\n                self.status = ComponentStatus.ERROR\r\n            elif error_level == ErrorLevel.WARN:\r\n                self.status = ComponentStatus.WARNING\r\n\r\n    def is_alive(self) -> bool:\r\n        """Check if component is alive based on heartbeat"""\r\n        with self.lock:\r\n            current_time = rospy.get_time()\r\n            return (current_time - self.last_heartbeat) < self.timeout\r\n\r\n    def get_status(self) -> ComponentStatus:\r\n        """Get current component status"""\r\n        with self.lock:\r\n            if not self.is_alive():\r\n                return ComponentStatus.ERROR  # Component timed out\r\n            return self.status\r\n\r\n    def get_error_count(self, error_level: ErrorLevel = None) -> int:\r\n        """Get count of errors, optionally filtered by level"""\r\n        with self.lock:\r\n            if error_level:\r\n                return len([e for e in self.error_history if e[\'level\'] == error_level])\r\n            return len(self.error_history)\r\n\r\n    def get_recent_errors(self, count: int = 10) -> list:\r\n        """Get recent errors"""\r\n        with self.lock:\r\n            return list(self.error_history)[-count:]\r\n\r\nclass SystemMonitor:\r\n    """Monitors the entire system for failures"""\r\n\r\n    def __init__(self):\r\n        self.components = {}  # component_name -> ComponentMonitor\r\n        self.global_error_handlers = []\r\n        self.system_status_publisher = rospy.Publisher(\'/system_status\', String, queue_size=10)\r\n        self.diagnostic_publisher = rospy.Publisher(\'/diagnostics\', DiagnosticArray, queue_size=10)\r\n        self.error_subscriber = rospy.Subscriber(\'/error_report\', String, self.error_callback)\r\n\r\n        # Start monitoring thread\r\n        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)\r\n        self.monitoring_thread.start()\r\n\r\n    def register_component(self, component_name: str, timeout: float = 5.0):\r\n        """Register a component for monitoring"""\r\n        if component_name not in self.components:\r\n            self.components[component_name] = ComponentMonitor(component_name, timeout)\r\n            rospy.loginfo(f"Registered component for monitoring: {component_name}")\r\n\r\n    def component_heartbeat(self, component_name: str):\r\n        """Component reports heartbeat"""\r\n        if component_name in self.components:\r\n            self.components[component_name].heartbeat()\r\n\r\n    def report_error(self, component_name: str, error_msg: str,\r\n                    error_level: ErrorLevel, error_type: ErrorType):\r\n        """Report an error from a specific component"""\r\n        if component_name in self.components:\r\n            self.components[component_name].report_error(error_msg, error_level, error_type)\r\n        else:\r\n            # Create monitor for unknown component\r\n            self.register_component(component_name)\r\n            self.components[component_name].report_error(error_msg, error_level, error_type)\r\n\r\n        # Log error based on level\r\n        if error_level == ErrorLevel.ERROR:\r\n            rospy.logerr(f"[{component_name}] {error_msg}")\r\n        elif error_level == ErrorLevel.WARN:\r\n            rospy.logwarn(f"[{component_name}] {error_msg}")\r\n        elif error_level == ErrorLevel.INFO:\r\n            rospy.loginfo(f"[{component_name}] {error_msg}")\r\n        elif error_level == ErrorLevel.DEBUG:\r\n            rospy.logdebug(f"[{component_name}] {error_msg}")\r\n\r\n    def get_system_status(self) -> dict:\r\n        """Get overall system status"""\r\n        status = {\r\n            \'timestamp\': rospy.get_time(),\r\n            \'components\': {},\r\n            \'overall_status\': ComponentStatus.OK,\r\n            \'error_count\': 0,\r\n            \'active_errors\': []\r\n        }\r\n\r\n        max_error_level = ErrorLevel.DEBUG\r\n\r\n        for name, monitor in self.components.items():\r\n            comp_status = monitor.get_status()\r\n            status[\'components\'][name] = {\r\n                \'status\': comp_status.value,\r\n                \'alive\': monitor.is_alive(),\r\n                \'error_count\': monitor.get_error_count()\r\n            }\r\n\r\n            # Determine overall system status\r\n            if comp_status == ComponentStatus.FATAL:\r\n                status[\'overall_status\'] = ComponentStatus.FATAL\r\n                max_error_level = ErrorLevel.FATAL\r\n            elif comp_status == ComponentStatus.ERROR and max_error_level < ErrorLevel.ERROR:\r\n                status[\'overall_status\'] = ComponentStatus.ERROR\r\n                max_error_level = ErrorLevel.ERROR\r\n            elif comp_status == ComponentStatus.WARNING and max_error_level < ErrorLevel.WARN:\r\n                if status[\'overall_status\'] != ComponentStatus.ERROR:\r\n                    status[\'overall_status\'] = ComponentStatus.WARNING\r\n                max_error_level = ErrorLevel.WARN\r\n\r\n            # Count total errors\r\n            status[\'error_count\'] += monitor.get_error_count()\r\n\r\n            # Get recent errors if component has errors\r\n            if monitor.get_error_count() > 0:\r\n                recent_errors = monitor.get_recent_errors(3)  # Last 3 errors\r\n                for error in recent_errors:\r\n                    status[\'active_errors\'].append({\r\n                        \'component\': name,\r\n                        \'message\': error[\'message\'],\r\n                        \'level\': error[\'level\'].name,\r\n                        \'timestamp\': error[\'timestamp\']\r\n                    })\r\n\r\n        return status\r\n\r\n    def _monitoring_loop(self):\r\n        """Continuous monitoring loop"""\r\n        rate = rospy.Rate(1)  # 1 Hz monitoring\r\n\r\n        while not rospy.is_shutdown():\r\n            try:\r\n                # Publish system status\r\n                system_status = self.get_system_status()\r\n                status_msg = String()\r\n                status_msg.data = json.dumps(system_status, indent=2)\r\n                self.system_status_publisher.publish(status_msg)\r\n\r\n                # Publish diagnostic information\r\n                self._publish_diagnostics(system_status)\r\n\r\n                rate.sleep()\r\n            except Exception as e:\r\n                rospy.logerr(f"Error in monitoring loop: {e}")\r\n\r\n    def _publish_diagnostics(self, system_status: dict):\r\n        """Publish ROS diagnostics message"""\r\n        diag_array = DiagnosticArray()\r\n        diag_array.header.stamp = rospy.Time.now()\r\n\r\n        for comp_name, comp_info in system_status[\'components\'].items():\r\n            diag_status = DiagnosticStatus()\r\n            diag_status.name = f"capstone/{comp_name}"\r\n            diag_status.hardware_id = comp_name\r\n\r\n            if comp_info[\'status\'] == \'ok\':\r\n                diag_status.level = DiagnosticStatus.OK\r\n                diag_status.message = "Component operating normally"\r\n            elif comp_info[\'status\'] == \'warning\':\r\n                diag_status.level = DiagnosticStatus.WARN\r\n                diag_status.message = "Component has warnings"\r\n            elif comp_info[\'status\'] == \'error\':\r\n                diag_status.level = DiagnosticStatus.ERROR\r\n                diag_status.message = "Component has errors"\r\n            elif comp_info[\'status\'] == \'fatal\':\r\n                diag_status.level = DiagnosticStatus.ERROR\r\n                diag_status.message = "Component has fatal errors"\r\n            else:\r\n                diag_status.level = DiagnosticStatus.STALE\r\n                diag_status.message = "Component status unknown"\r\n\r\n            diag_status.values = [\r\n                {\'key\': \'alive\', \'value\': str(comp_info[\'alive\'])},\r\n                {\'key\': \'error_count\', \'value\': str(comp_info[\'error_count\'])}\r\n            ]\r\n\r\n            diag_array.status.append(diag_status)\r\n\r\n        self.diagnostic_publisher.publish(diag_array)\r\n\r\n    def error_callback(self, msg):\r\n        """Handle incoming error messages from other nodes"""\r\n        try:\r\n            error_data = json.loads(msg.data)\r\n            component = error_data.get(\'component\', \'unknown\')\r\n            message = error_data.get(\'message\', \'Unknown error\')\r\n            level_str = error_data.get(\'level\', \'ERROR\')\r\n            type_str = error_data.get(\'type\', \'SOFTWARE\')\r\n\r\n            # Convert strings back to enums\r\n            level = ErrorLevel[level_str.upper()]\r\n            error_type = ErrorType[type_str.upper()]\r\n\r\n            self.report_error(component, message, level, error_type)\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f"Error parsing error callback: {e}")\n'})}),"\n",(0,o.jsx)(e.h4,{id:"error-classification-system",children:"Error Classification System"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class ErrorClassifier:\r\n    \"\"\"Classifies errors by type and severity\"\"\"\r\n\r\n    def __init__(self):\r\n        self.error_patterns = self._initialize_error_patterns()\r\n\r\n    def _initialize_error_patterns(self) -> dict:\r\n        \"\"\"Initialize known error patterns and their classifications\"\"\"\r\n        return {\r\n            # Communication errors\r\n            'connection refused': (ErrorType.COMMUNICATION, ErrorLevel.ERROR),\r\n            'timeout': (ErrorType.COMMUNICATION, ErrorLevel.WARN),\r\n            'network': (ErrorType.COMMUNICATION, ErrorLevel.ERROR),\r\n            'connection lost': (ErrorType.COMMUNICATION, ErrorLevel.ERROR),\r\n\r\n            # Hardware errors\r\n            'motor fault': (ErrorType.HARDWARE, ErrorLevel.ERROR),\r\n            'encoder error': (ErrorType.HARDWARE, ErrorLevel.ERROR),\r\n            'gripper fault': (ErrorType.HARDWARE, ErrorLevel.ERROR),\r\n            'sensor failure': (ErrorType.HARDWARE, ErrorLevel.ERROR),\r\n            'overheating': (ErrorType.HARDWARE, ErrorLevel.WARN),\r\n            'low battery': (ErrorType.HARDWARE, ErrorLevel.WARN),\r\n\r\n            # Software errors\r\n            'segmentation fault': (ErrorType.SOFTWARE, ErrorLevel.FATAL),\r\n            'memory error': (ErrorType.SOFTWARE, ErrorLevel.ERROR),\r\n            'null pointer': (ErrorType.SOFTWARE, ErrorLevel.ERROR),\r\n            'exception': (ErrorType.SOFTWARE, ErrorLevel.ERROR),\r\n            'assertion failed': (ErrorType.SOFTWARE, ErrorLevel.ERROR),\r\n\r\n            # Environmental errors\r\n            'obstacle detected': (ErrorType.ENVIRONMENTAL, ErrorLevel.WARN),\r\n            'navigation failed': (ErrorType.ENVIRONMENTAL, ErrorLevel.WARN),\r\n            'object not found': (ErrorType.ENVIRONMENTAL, ErrorLevel.WARN),\r\n            'grasp failed': (ErrorType.ENVIRONMENTAL, ErrorLevel.WARN),\r\n\r\n            # Safety errors\r\n            'collision detected': (ErrorType.SAFETY, ErrorLevel.ERROR),\r\n            'safety limit exceeded': (ErrorType.SAFETY, ErrorLevel.ERROR),\r\n            'emergency stop': (ErrorType.SAFETY, ErrorLevel.FATAL),\r\n        }\r\n\r\n    def classify_error(self, error_message: str) -> tuple:\r\n        \"\"\"Classify an error message by type and level\"\"\"\r\n        error_message_lower = error_message.lower()\r\n\r\n        # Check for known patterns\r\n        for pattern, (error_type, error_level) in self.error_patterns.items():\r\n            if pattern.lower() in error_message_lower:\r\n                return error_type, error_level\r\n\r\n        # Default classification based on keywords\r\n        if any(keyword in error_message_lower for keyword in ['critical', 'fatal', 'crash']):\r\n            return ErrorType.SOFTWARE, ErrorLevel.FATAL\r\n        elif any(keyword in error_message_lower for keyword in ['error', 'failed', 'failure']):\r\n            return ErrorType.SOFTWARE, ErrorLevel.ERROR\r\n        elif any(keyword in error_message_lower for keyword in ['warning', 'warn', 'problem']):\r\n            return ErrorType.SOFTWARE, ErrorLevel.WARN\r\n        elif any(keyword in error_message_lower for keyword in ['info', 'notice', 'status']):\r\n            return ErrorType.SOFTWARE, ErrorLevel.INFO\r\n        else:\r\n            return ErrorType.SOFTWARE, ErrorLevel.DEBUG\r\n\r\n    def get_recovery_hint(self, error_message: str) -> str:\r\n        \"\"\"Get a suggested recovery action for an error\"\"\"\r\n        error_type, error_level = self.classify_error(error_message)\r\n\r\n        recovery_hints = {\r\n            (ErrorType.COMMUNICATION, ErrorLevel.ERROR): \"Check network connections and restart communication modules\",\r\n            (ErrorType.HARDWARE, ErrorLevel.ERROR): \"Check hardware connections and perform hardware diagnostics\",\r\n            (ErrorType.ENVIRONMENTAL, ErrorLevel.WARN): \"Reassess environment and replan accordingly\",\r\n            (ErrorType.SAFETY, ErrorLevel.ERROR): \"Stop all motion and perform safety check\",\r\n            (ErrorType.SOFTWARE, ErrorLevel.FATAL): \"Restart system and reload software\"\r\n        }\r\n\r\n        return recovery_hints.get((error_type, error_level), \"No specific recovery action available\")\r\n\r\nclass ErrorSeverityCalculator:\r\n    \"\"\"Calculates error severity based on multiple factors\"\"\"\r\n\r\n    def __init__(self):\r\n        self.component_criticality = {\r\n            'navigation': 3,  # High criticality\r\n            'manipulation': 3,  # High criticality\r\n            'perception': 2,  # Medium criticality\r\n            'task_planning': 2,  # Medium criticality\r\n            'voice_processing': 1,  # Low criticality\r\n            'localization': 3,  # High criticality\r\n        }\r\n\r\n    def calculate_severity(self, error_type: ErrorType, error_level: ErrorLevel,\r\n                          component_name: str, frequency: int = 1) -> int:\r\n        \"\"\"Calculate overall error severity score\"\"\"\r\n        # Base severity from error level\r\n        level_multiplier = {\r\n            ErrorLevel.DEBUG: 1,\r\n            ErrorLevel.INFO: 1,\r\n            ErrorLevel.WARN: 2,\r\n            ErrorLevel.ERROR: 3,\r\n            ErrorLevel.FATAL: 4\r\n        }\r\n\r\n        # Component criticality multiplier\r\n        criticality = self.component_criticality.get(component_name, 1)\r\n\r\n        # Frequency multiplier (errors occurring frequently are more severe)\r\n        freq_multiplier = min(frequency, 5)  # Cap at 5\r\n\r\n        # Type-based adjustments\r\n        type_multiplier = 1.0\r\n        if error_type == ErrorType.SAFETY:\r\n            type_multiplier = 2.0  # Safety errors are always more severe\r\n        elif error_type == ErrorType.HARDWARE:\r\n            type_multiplier = 1.5  # Hardware errors are more severe\r\n\r\n        severity_score = (level_multiplier[error_level] *\r\n                         criticality *\r\n                         freq_multiplier *\r\n                         type_multiplier)\r\n\r\n        return int(severity_score)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"2-recovery-and-graceful-degradation",children:"2. Recovery and Graceful Degradation"}),"\n",(0,o.jsx)(e.h4,{id:"recovery-strategy-manager",children:"Recovery Strategy Manager"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import subprocess\r\nimport signal\r\nimport os\r\nfrom typing import Callable, List, Optional\r\nimport time\r\n\r\nclass RecoveryStrategy:\r\n    """Base class for recovery strategies"""\r\n\r\n    def __init__(self, name: str, description: str):\r\n        self.name = name\r\n        self.description = description\r\n\r\n    def execute(self, error_context: dict) -> bool:\r\n        """Execute the recovery strategy"""\r\n        raise NotImplementedError\r\n\r\n    def can_handle(self, error_context: dict) -> bool:\r\n        """Check if this strategy can handle the given error"""\r\n        raise NotImplementedError\r\n\r\nclass RetryStrategy(RecoveryStrategy):\r\n    """Retry the failed operation"""\r\n\r\n    def __init__(self):\r\n        super().__init__("retry", "Retry the failed operation with exponential backoff")\r\n\r\n    def can_handle(self, error_context: dict) -> bool:\r\n        return error_context.get(\'error_type\') in [ErrorType.COMMUNICATION, ErrorType.SOFTWARE]\r\n\r\n    def execute(self, error_context: dict) -> bool:\r\n        """Execute retry with exponential backoff"""\r\n        max_retries = error_context.get(\'max_retries\', 3)\r\n        base_delay = error_context.get(\'base_delay\', 1.0)\r\n\r\n        for attempt in range(max_retries):\r\n            rospy.loginfo(f"Retry attempt {attempt + 1}/{max_retries}")\r\n\r\n            # Wait with exponential backoff\r\n            delay = base_delay * (2 ** attempt)\r\n            time.sleep(delay)\r\n\r\n            # Try to execute the original operation\r\n            # This would be passed as a function in practice\r\n            if error_context.get(\'retry_function\'):\r\n                try:\r\n                    success = error_context[\'retry_function\']()\r\n                    if success:\r\n                        rospy.loginfo("Retry successful")\r\n                        return True\r\n                except Exception as e:\r\n                    rospy.logwarn(f"Retry attempt {attempt + 1} failed: {e}")\r\n\r\n        rospy.logerr("All retry attempts failed")\r\n        return False\r\n\r\nclass ResetStrategy(RecoveryStrategy):\r\n    """Reset the failing component"""\r\n\r\n    def __init__(self):\r\n        super().__init__("reset", "Reset the failing component or system")\r\n\r\n    def can_handle(self, error_context: dict) -> bool:\r\n        return error_context.get(\'error_type\') in [ErrorType.HARDWARE, ErrorType.SOFTWARE]\r\n\r\n    def execute(self, error_context: dict) -> bool:\r\n        """Execute component reset"""\r\n        component = error_context.get(\'component\', \'unknown\')\r\n        rospy.loginfo(f"Resetting component: {component}")\r\n\r\n        try:\r\n            # For ROS nodes, we might need to restart them\r\n            if \'node_name\' in error_context:\r\n                node_name = error_context[\'node_name\']\r\n                # Kill the node process\r\n                subprocess.run([\'rosnode\', \'kill\', node_name], check=False)\r\n                # Wait for node to be killed\r\n                time.sleep(2)\r\n                # In practice, the node would need to be restarted\r\n                rospy.loginfo(f"Reset complete for node: {node_name}")\r\n                return True\r\n\r\n            # For hardware components, send reset command\r\n            if \'hardware_command\' in error_context:\r\n                # Execute hardware reset command\r\n                # This is system-specific\r\n                rospy.loginfo(f"Hardware reset command sent for: {component}")\r\n                return True\r\n\r\n            # Default: just log the reset\r\n            rospy.loginfo(f"Component reset simulated for: {component}")\r\n            return True\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f"Reset failed: {e}")\r\n            return False\r\n\r\nclass FallbackStrategy(RecoveryStrategy):\r\n    """Use a fallback or alternative approach"""\r\n\r\n    def __init__(self):\r\n        super().__init__("fallback", "Use alternative approach or degrade functionality")\r\n\r\n    def can_handle(self, error_context: dict) -> bool:\r\n        return True  # Can handle any error as fallback\r\n\r\n    def execute(self, error_context: dict) -> bool:\r\n        """Execute fallback strategy"""\r\n        component = error_context.get(\'component\', \'unknown\')\r\n        error_type = error_context.get(\'error_type\', ErrorType.SOFTWARE)\r\n\r\n        rospy.loginfo(f"Activating fallback for component: {component}")\r\n\r\n        # Different fallbacks based on component and error type\r\n        if component == \'navigation\' and error_type == ErrorType.ENVIRONMENTAL:\r\n            # Use safe navigation mode\r\n            rospy.loginfo("Switching to safe navigation mode")\r\n            # Implement safe navigation logic\r\n            return True\r\n\r\n        elif component == \'perception\' and error_type == ErrorType.ENVIRONMENTAL:\r\n            # Use cached data or alternative sensors\r\n            rospy.loginfo("Using cached perception data or alternative sensors")\r\n            # Implement fallback perception\r\n            return True\r\n\r\n        elif component == \'manipulation\' and error_type == ErrorType.HARDWARE:\r\n            # Switch to safe position or emergency stop\r\n            rospy.loginfo("Moving to safe position due to manipulation error")\r\n            # Implement safe positioning\r\n            return True\r\n\r\n        else:\r\n            # General fallback - degrade gracefully\r\n            rospy.loginfo("Activating general fallback - degrading functionality")\r\n            return True\r\n\r\nclass EmergencyStopStrategy(RecoveryStrategy):\r\n    """Emergency stop for safety-critical situations"""\r\n\r\n    def __init__(self):\r\n        super().__init__("emergency_stop", "Immediate stop for safety-critical situations")\r\n\r\n    def can_handle(self, error_context: dict) -> bool:\r\n        return error_context.get(\'error_type\') == ErrorType.SAFETY\r\n\r\n    def execute(self, error_context: dict) -> bool:\r\n        """Execute emergency stop"""\r\n        rospy.logerr("EMERGENCY STOP ACTIVATED - HALTING ALL MOTION")\r\n\r\n        # Stop all robot motion immediately\r\n        cmd_vel_pub = rospy.Publisher(\'/cmd_vel\', Twist, queue_size=1, latch=True)\r\n        stop_cmd = Twist()\r\n        cmd_vel_pub.publish(stop_cmd)\r\n\r\n        # Stop manipulator if active\r\n        try:\r\n            # This would send stop commands to manipulator controllers\r\n            pass\r\n        except:\r\n            pass\r\n\r\n        # Log the emergency stop\r\n        rospy.logerr(f"Emergency stop executed due to: {error_context.get(\'error_message\', \'unknown error\')}")\r\n        return True\r\n\r\nclass RecoveryManager:\r\n    """Manages recovery strategies and executes appropriate ones"""\r\n\r\n    def __init__(self):\r\n        self.strategies = [\r\n            EmergencyStopStrategy(),\r\n            RetryStrategy(),\r\n            ResetStrategy(),\r\n            FallbackStrategy()\r\n        ]\r\n        self.error_classifier = ErrorClassifier()\r\n        self.severity_calculator = ErrorSeverityCalculator()\r\n\r\n    def handle_error(self, error_context: dict) -> bool:\r\n        """Handle an error by selecting and executing appropriate recovery strategy"""\r\n        error_msg = error_context.get(\'error_message\', \'Unknown error\')\r\n        component = error_context.get(\'component\', \'unknown\')\r\n        error_type, error_level = self.error_classifier.classify_error(error_msg)\r\n\r\n        # Update context with classified information\r\n        error_context[\'error_type\'] = error_type\r\n        error_context[\'error_level\'] = error_level\r\n\r\n        rospy.loginfo(f"Handling error in {component}: {error_msg} (type: {error_type}, level: {error_level})")\r\n\r\n        # Calculate severity\r\n        severity = self.severity_calculator.calculate_severity(\r\n            error_type, error_level, component\r\n        )\r\n        error_context[\'severity\'] = severity\r\n\r\n        # Select appropriate recovery strategy\r\n        for strategy in self.strategies:\r\n            if strategy.can_handle(error_context):\r\n                rospy.loginfo(f"Executing recovery strategy: {strategy.name}")\r\n                success = strategy.execute(error_context)\r\n\r\n                if success:\r\n                    rospy.loginfo(f"Recovery successful using {strategy.name}")\r\n                    return True\r\n                else:\r\n                    rospy.logwarn(f"Recovery failed using {strategy.name}")\r\n\r\n        # If no strategy worked, escalate\r\n        rospy.logerr("No recovery strategy was successful")\r\n        return False\r\n\r\n    def register_strategy(self, strategy: RecoveryStrategy):\r\n        """Register a new recovery strategy"""\r\n        self.strategies.append(strategy)\r\n\r\n    def get_recovery_options(self, error_context: dict) -> List[str]:\r\n        """Get list of applicable recovery options for an error"""\r\n        options = []\r\n        for strategy in self.strategies:\r\n            if strategy.can_handle(error_context):\r\n                options.append(strategy.name)\r\n        return options\n'})}),"\n",(0,o.jsx)(e.h4,{id:"graceful-degradation-system",children:"Graceful Degradation System"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class DegradationLevel(Enum):\r\n    FULL_FUNCTIONAL = \"full_functional\"\r\n    PARTIAL_FUNCTIONAL = \"partial_functional\"\r\n    SAFE_MODE = \"safe_mode\"\r\n    EMERGENCY_STOP = \"emergency_stop\"\r\n\r\nclass DegradationManager:\r\n    \"\"\"Manages system degradation based on error severity\"\"\"\r\n\r\n    def __init__(self):\r\n        self.current_level = DegradationLevel.FULL_FUNCTIONAL\r\n        self.degradation_thresholds = {\r\n            0: DegradationLevel.FULL_FUNCTIONAL,      # No errors\r\n            1: DegradationLevel.FULL_FUNCTIONAL,      # Minor errors\r\n            3: DegradationLevel.PARTIAL_FUNCTIONAL,   # Multiple minor errors\r\n            5: DegradationLevel.SAFE_MODE,            # Major errors\r\n            8: DegradationLevel.EMERGENCY_STOP        # Critical errors\r\n        }\r\n        self.functionality_map = self._initialize_functionality_map()\r\n\r\n    def _initialize_functionality_map(self) -> dict:\r\n        \"\"\"Initialize mapping of degradation levels to functionality\"\"\"\r\n        return {\r\n            DegradationLevel.FULL_FUNCTIONAL: {\r\n                'navigation': True,\r\n                'manipulation': True,\r\n                'perception': True,\r\n                'task_planning': True,\r\n                'voice_processing': True,\r\n                'max_speed': 1.0,\r\n                'max_payload': 1.0,\r\n                'precision_mode': True\r\n            },\r\n            DegradationLevel.PARTIAL_FUNCTIONAL: {\r\n                'navigation': True,\r\n                'manipulation': False,  # Disable manipulation\r\n                'perception': True,\r\n                'task_planning': True,\r\n                'voice_processing': True,\r\n                'max_speed': 0.7,  # Reduce speed\r\n                'max_payload': 0.5,  # Reduce payload\r\n                'precision_mode': False\r\n            },\r\n            DegradationLevel.SAFE_MODE: {\r\n                'navigation': True,  # Can still navigate to safe location\r\n                'manipulation': False,\r\n                'perception': True,  # Basic perception for safety\r\n                'task_planning': False,  # No complex planning\r\n                'voice_processing': True,  # Can still receive commands\r\n                'max_speed': 0.3,  # Very slow\r\n                'max_payload': 0.0,  # No payload\r\n                'precision_mode': False\r\n            },\r\n            DegradationLevel.EMERGENCY_STOP: {\r\n                'navigation': False,  # Stop all motion\r\n                'manipulation': False,\r\n                'perception': False,  # Minimal perception only\r\n                'task_planning': False,\r\n                'voice_processing': True,  # Still listen for commands\r\n                'max_speed': 0.0,  # No movement\r\n                'max_payload': 0.0,\r\n                'precision_mode': False\r\n            }\r\n        }\r\n\r\n    def update_degradation_level(self, total_error_score: int) -> DegradationLevel:\r\n        \"\"\"Update degradation level based on total error score\"\"\"\r\n        # Find the appropriate degradation level\r\n        level = DegradationLevel.FULL_FUNCTIONAL\r\n        for threshold, degradation_level in sorted(self.degradation_thresholds.items(), reverse=True):\r\n            if total_error_score >= threshold:\r\n                level = degradation_level\r\n                break\r\n\r\n        if level != self.current_level:\r\n            old_level = self.current_level\r\n            self.current_level = level\r\n            self._apply_degradation_changes(old_level, level)\r\n\r\n        return self.current_level\r\n\r\n    def _apply_degradation_changes(self, old_level: DegradationLevel, new_level: DegradationLevel):\r\n        \"\"\"Apply changes when degradation level changes\"\"\"\r\n        rospy.loginfo(f\"System degradation level changed: {old_level.value} -> {new_level.value}\")\r\n\r\n        # Publish degradation level\r\n        degradation_pub = rospy.Publisher('/system_degradation_level', String, queue_size=1, latch=True)\r\n        level_msg = String()\r\n        level_msg.data = new_level.value\r\n        degradation_pub.publish(level_msg)\r\n\r\n        # Apply functionality restrictions\r\n        functionality = self.functionality_map[new_level]\r\n\r\n        # Example: Reduce navigation speed\r\n        if not functionality['navigation']:\r\n            # Stop all navigation\r\n            cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1, latch=True)\r\n            stop_cmd = Twist()\r\n            cmd_vel_pub.publish(stop_cmd)\r\n            rospy.loginfo(\"Navigation disabled due to degradation\")\r\n        else:\r\n            # Set speed limits\r\n            # This would interface with navigation system\r\n            pass\r\n\r\n        # Example: Disable manipulation\r\n        if not functionality['manipulation']:\r\n            # Stop any ongoing manipulation\r\n            # This would interface with manipulation system\r\n            rospy.loginfo(\"Manipulation disabled due to degradation\")\r\n\r\n        # Log the changes\r\n        rospy.loginfo(f\"Applied functionality changes: {functionality}\")\r\n\r\n    def is_functionality_available(self, function_name: str) -> bool:\r\n        \"\"\"Check if specific functionality is available at current degradation level\"\"\"\r\n        functionality = self.functionality_map[self.current_level]\r\n        return functionality.get(function_name, False)\r\n\r\n    def get_current_functionality(self) -> dict:\r\n        \"\"\"Get current system functionality status\"\"\"\r\n        return self.functionality_map[self.current_level].copy()\r\n\r\n    def get_degradation_status(self) -> dict:\r\n        \"\"\"Get comprehensive degradation status\"\"\"\r\n        return {\r\n            'current_level': self.current_level.value,\r\n            'functionality': self.get_current_functionality(),\r\n            'message': f\"System operating at {self.current_level.value} level\"\r\n        }\n"})}),"\n",(0,o.jsx)(e.h3,{id:"3-status-reporting-and-communication",children:"3. Status Reporting and Communication"}),"\n",(0,o.jsx)(e.h4,{id:"status-reporting-system",children:"Status Reporting System"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from datetime import datetime\r\nimport psutil\r\nfrom std_msgs.msg import Header\r\nfrom diagnostic_msgs.msg import KeyValue\r\n\r\nclass StatusReporter:\r\n    \"\"\"Comprehensive status reporting system\"\"\"\r\n\r\n    def __init__(self):\r\n        self.status_publisher = rospy.Publisher('/system_status_detailed', String, queue_size=10)\r\n        self.health_publisher = rospy.Publisher('/system_health', String, queue_size=10)\r\n        self.heartbeat_publisher = rospy.Publisher('/system_heartbeat', String, queue_size=10)\r\n\r\n        # Start heartbeat thread\r\n        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)\r\n        self.heartbeat_thread.start()\r\n\r\n    def _heartbeat_loop(self):\r\n        \"\"\"Publish system heartbeat\"\"\"\r\n        rate = rospy.Rate(1)  # 1 Hz heartbeat\r\n\r\n        while not rospy.is_shutdown():\r\n            try:\r\n                heartbeat_msg = {\r\n                    'timestamp': rospy.get_time(),\r\n                    'node': rospy.get_name(),\r\n                    'status': 'running',\r\n                    'uptime': rospy.get_time() - rospy.get_param('start_time', rospy.get_time())\r\n                }\r\n\r\n                heartbeat_str = json.dumps(heartbeat_msg)\r\n                self.heartbeat_publisher.publish(String(data=heartbeat_str))\r\n                rate.sleep()\r\n            except Exception as e:\r\n                rospy.logerr(f\"Error in heartbeat loop: {e}\")\r\n\r\n    def publish_system_status(self, system_monitor: SystemMonitor, recovery_manager: RecoveryManager):\r\n        \"\"\"Publish comprehensive system status\"\"\"\r\n        status_data = {\r\n            'timestamp': rospy.get_time(),\r\n            'system_status': system_monitor.get_system_status(),\r\n            'degradation_status': self._get_degradation_status(),\r\n            'resource_usage': self._get_resource_usage(),\r\n            'active_recovery_options': self._get_active_recovery_options(system_monitor),\r\n            'uptime': rospy.get_time() - rospy.get_param('start_time', rospy.get_time())\r\n        }\r\n\r\n        status_json = json.dumps(status_data, indent=2)\r\n        self.status_publisher.publish(String(data=status_json))\r\n\r\n    def _get_degradation_status(self) -> dict:\r\n        \"\"\"Get current degradation status\"\"\"\r\n        # This would interface with DegradationManager\r\n        # For now, return a placeholder\r\n        return {\r\n            'level': 'full_functional',\r\n            'functionality': {\r\n                'navigation': True,\r\n                'manipulation': True,\r\n                'perception': True\r\n            }\r\n        }\r\n\r\n    def _get_resource_usage(self) -> dict:\r\n        \"\"\"Get system resource usage\"\"\"\r\n        return {\r\n            'cpu_percent': psutil.cpu_percent(interval=1),\r\n            'memory_percent': psutil.virtual_memory().percent,\r\n            'disk_percent': psutil.disk_usage('/').percent,\r\n            'temperature': self._get_temperature(),  # System-specific\r\n            'network_io': psutil.net_io_counters()._asdict() if psutil.HAS_NET_IO_COUNTERS else {}\r\n        }\r\n\r\n    def _get_temperature(self) -> Optional[float]:\r\n        \"\"\"Get system temperature (if available)\"\"\"\r\n        try:\r\n            # Try to get temperature from system sensors\r\n            if hasattr(psutil, \"sensors_temperatures\"):\r\n                temps = psutil.sensors_temperatures()\r\n                if temps:\r\n                    # Get CPU temperature if available\r\n                    for name, entries in temps.items():\r\n                        if 'cpu' in name.lower() or 'core' in name.lower():\r\n                            if entries:\r\n                                return entries[0].current\r\n            return None\r\n        except:\r\n            return None\r\n\r\n    def _get_active_recovery_options(self, system_monitor: SystemMonitor) -> dict:\r\n        \"\"\"Get currently available recovery options\"\"\"\r\n        # This would analyze current system state to determine available recovery options\r\n        # For now, return a placeholder\r\n        return {\r\n            'retry_available': True,\r\n            'reset_available': True,\r\n            'fallback_available': True,\r\n            'emergency_stop_available': True\r\n        }\r\n\r\n    def publish_health_report(self, system_monitor: SystemMonitor):\r\n        \"\"\"Publish detailed health report\"\"\"\r\n        system_status = system_monitor.get_system_status()\r\n\r\n        health_report = {\r\n            'header': {\r\n                'stamp': rospy.Time.now().to_sec(),\r\n                'frame_id': 'system'\r\n            },\r\n            'status': self._calculate_health_status(system_status),\r\n            'components': system_status['components'],\r\n            'errors': system_status['active_errors'][-10:],  # Last 10 errors\r\n            'metrics': self._calculate_health_metrics(system_status)\r\n        }\r\n\r\n        health_json = json.dumps(health_report, indent=2)\r\n        self.health_publisher.publish(String(data=health_json))\r\n\r\n    def _calculate_health_status(self, system_status: dict) -> int:\r\n        \"\"\"Calculate overall system health status (0=bad, 1=ok, 2=good)\"\"\"\r\n        overall_status = system_status['overall_status']\r\n\r\n        if overall_status == ComponentStatus.FATAL:\r\n            return 0  # Bad\r\n        elif overall_status == ComponentStatus.ERROR:\r\n            return 0  # Bad\r\n        elif overall_status == ComponentStatus.WARNING:\r\n            return 1  # Ok\r\n        else:\r\n            return 2  # Good\r\n\r\n    def _calculate_health_metrics(self, system_status: dict) -> dict:\r\n        \"\"\"Calculate health metrics\"\"\"\r\n        total_components = len(system_status['components'])\r\n        healthy_components = sum(1 for comp in system_status['components'].values()\r\n                               if comp['status'] == 'ok')\r\n\r\n        error_rate = system_status['error_count'] / max(total_components, 1)\r\n\r\n        return {\r\n            'total_components': total_components,\r\n            'healthy_components': healthy_components,\r\n            'error_rate': error_rate,\r\n            'health_score': healthy_components / max(total_components, 1)\r\n        }\r\n\r\nclass UserStatusInterface:\r\n    \"\"\"Interface for communicating status to users\"\"\"\r\n\r\n    def __init__(self):\r\n        self.voice_publisher = rospy.Publisher('/voice_output', String, queue_size=10)\r\n        self.display_publisher = rospy.Publisher('/display_output', String, queue_size=10)\r\n        self.led_publisher = rospy.Publisher('/led_status', String, queue_size=10)\r\n\r\n    def report_status_to_user(self, status_data: dict):\r\n        \"\"\"Report system status to user through multiple channels\"\"\"\r\n        # Extract relevant information\r\n        overall_status = status_data.get('system_status', {}).get('overall_status', 'unknown')\r\n        active_errors = status_data.get('system_status', {}).get('active_errors', [])\r\n        degradation_level = status_data.get('degradation_status', {}).get('level', 'full_functional')\r\n\r\n        # Voice feedback\r\n        voice_msg = self._generate_voice_feedback(overall_status, degradation_level, active_errors)\r\n        self.voice_publisher.publish(String(data=voice_msg))\r\n\r\n        # Display feedback\r\n        display_msg = self._generate_display_feedback(overall_status, degradation_level, active_errors)\r\n        self.display_publisher.publish(String(data=display_msg))\r\n\r\n        # LED status\r\n        led_status = self._determine_led_status(overall_status, degradation_level)\r\n        self.led_publisher.publish(String(data=led_status))\r\n\r\n    def _generate_voice_feedback(self, overall_status: str, degradation_level: str, active_errors: list) -> str:\r\n        \"\"\"Generate voice feedback message\"\"\"\r\n        if overall_status == 'fatal':\r\n            return \"Emergency: System failure detected. Stopping all operations. Please contact support.\"\r\n        elif overall_status == 'error':\r\n            if degradation_level == 'safe_mode':\r\n                return f\"Warning: System in safe mode due to errors. {len(active_errors)} active issues detected.\"\r\n            else:\r\n                return f\"Error: Issues detected in system. Continuing with reduced functionality.\"\r\n        elif overall_status == 'warning':\r\n            return f\"Warning: {len(active_errors)} issues detected. System operational but monitor closely.\"\r\n        else:\r\n            return \"System status normal. All components operating correctly.\"\r\n\r\n    def _generate_display_feedback(self, overall_status: str, degradation_level: str, active_errors: list) -> str:\r\n        \"\"\"Generate display feedback message\"\"\"\r\n        status_lines = [\r\n            f\"System Status: {overall_status.upper()}\",\r\n            f\"Degradation Level: {degradation_level.upper()}\",\r\n            f\"Active Errors: {len(active_errors)}\",\r\n            f\"Time: {datetime.now().strftime('%H:%M:%S')}\"\r\n        ]\r\n\r\n        if active_errors:\r\n            status_lines.append(\"Recent Errors:\")\r\n            for error in active_errors[-3:]:  # Show last 3 errors\r\n                status_lines.append(f\"  - {error.get('component', 'unknown')}: {error.get('message', 'unknown')}\")\r\n\r\n        return \"\\n\".join(status_lines)\r\n\r\n    def _determine_led_status(self, overall_status: str, degradation_level: str) -> str:\r\n        \"\"\"Determine LED status based on system state\"\"\"\r\n        if overall_status == 'fatal':\r\n            return \"RED_FAST_BLINK\"  # Critical failure\r\n        elif overall_status == 'error':\r\n            if degradation_level == 'emergency_stop':\r\n                return \"RED_SOLID\"  # Emergency stop\r\n            else:\r\n                return \"YELLOW_BLINK\"  # Error condition\r\n        elif overall_status == 'warning':\r\n            return \"YELLOW_SOLID\"  # Warning\r\n        else:\r\n            return \"GREEN_SOLID\"  # Normal operation\n"})}),"\n",(0,o.jsx)(e.h3,{id:"4-integration-and-coordination",children:"4. Integration and Coordination"}),"\n",(0,o.jsx)(e.h4,{id:"failure-handling-coordinator",children:"Failure Handling Coordinator"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class FailureHandlingCoordinator:\r\n    """Coordinates all failure handling components"""\r\n\r\n    def __init__(self):\r\n        self.system_monitor = SystemMonitor()\r\n        self.recovery_manager = RecoveryManager()\r\n        self.degradation_manager = DegradationManager()\r\n        self.status_reporter = StatusReporter()\r\n        self.user_interface = UserStatusInterface()\r\n\r\n        # Register critical components for monitoring\r\n        self._register_critical_components()\r\n\r\n        # Start coordination thread\r\n        self.coordination_thread = threading.Thread(target=self._coordination_loop, daemon=True)\r\n        self.coordination_thread.start()\r\n\r\n    def _register_critical_components(self):\r\n        """Register all system components for monitoring"""\r\n        critical_components = [\r\n            \'navigation\',\r\n            \'manipulation\',\r\n            \'perception\',\r\n            \'task_planning\',\r\n            \'voice_processing\',\r\n            \'localization\',\r\n            \'sensors\',\r\n            \'actuators\'\r\n        ]\r\n\r\n        for component in critical_components:\r\n            self.system_monitor.register_component(component)\r\n\r\n    def handle_component_error(self, component_name: str, error_message: str,\r\n                             error_level: ErrorLevel = ErrorLevel.ERROR):\r\n        """Handle an error from a specific component"""\r\n        # Classify the error\r\n        error_classifier = ErrorClassifier()\r\n        error_type, classified_level = error_classifier.classify_error(error_message)\r\n\r\n        # Report to system monitor\r\n        self.system_monitor.report_error(component_name, error_message, classified_level, error_type)\r\n\r\n        # Create error context for recovery\r\n        error_context = {\r\n            \'component\': component_name,\r\n            \'error_message\': error_message,\r\n            \'error_type\': error_type,\r\n            \'error_level\': classified_level,\r\n            \'timestamp\': rospy.get_time(),\r\n            \'severity\': 0  # Will be calculated by recovery manager\r\n        }\r\n\r\n        # Attempt recovery\r\n        recovery_success = self.recovery_manager.handle_error(error_context)\r\n\r\n        # Update degradation level based on current error state\r\n        system_status = self.system_monitor.get_system_status()\r\n        total_errors = system_status[\'error_count\']\r\n        new_degradation = self.degradation_manager.update_degradation_level(total_errors)\r\n\r\n        # Publish updated status\r\n        self.status_reporter.publish_system_status(self.system_monitor, self.recovery_manager)\r\n\r\n        # Report to user if needed\r\n        status_data = {\r\n            \'system_status\': system_status,\r\n            \'degradation_status\': self.degradation_manager.get_degradation_status()\r\n        }\r\n        self.user_interface.report_status_to_user(status_data)\r\n\r\n        return recovery_success\r\n\r\n    def _coordination_loop(self):\r\n        """Main coordination loop"""\r\n        rate = rospy.Rate(0.1)  # 0.1 Hz (every 10 seconds)\r\n\r\n        while not rospy.is_shutdown():\r\n            try:\r\n                # Publish detailed status\r\n                self.status_reporter.publish_system_status(self.system_monitor, self.recovery_manager)\r\n\r\n                # Publish health report\r\n                self.status_reporter.publish_health_report(self.system_monitor)\r\n\r\n                # Check for any necessary actions\r\n                self._check_system_conditions()\r\n\r\n                rate.sleep()\r\n            except Exception as e:\r\n                rospy.logerr(f"Error in coordination loop: {e}")\r\n\r\n    def _check_system_conditions(self):\r\n        """Check system conditions and take appropriate actions"""\r\n        system_status = self.system_monitor.get_system_status()\r\n\r\n        # Check for high error rates\r\n        if system_status[\'error_count\'] > 10:  # Arbitrary threshold\r\n            rospy.logwarn("High error rate detected, reviewing system state")\r\n\r\n        # Check individual component health\r\n        for comp_name, comp_info in system_status[\'components\'].items():\r\n            if not comp_info[\'alive\'] and comp_info[\'status\'] != \'ok\':\r\n                rospy.logwarn(f"Component {comp_name} is not responding")\r\n\r\n    def get_system_health_summary(self) -> dict:\r\n        """Get comprehensive system health summary"""\r\n        system_status = self.system_monitor.get_system_status()\r\n        degradation_status = self.degradation_manager.get_degradation_status()\r\n        resource_usage = self.status_reporter._get_resource_usage()\r\n\r\n        return {\r\n            \'system_status\': system_status,\r\n            \'degradation_status\': degradation_status,\r\n            \'resource_usage\': resource_usage,\r\n            \'recovery_status\': {\r\n                \'last_recovery_time\': getattr(self, \'_last_recovery_time\', 0),\r\n                \'recovery_success_rate\': getattr(self, \'_recovery_success_rate\', 1.0)\r\n            }\r\n        }\r\n\r\n    def component_heartbeat(self, component_name: str):\r\n        """Handle component heartbeat"""\r\n        self.system_monitor.component_heartbeat(component_name)\r\n\r\nclass SafeOperationManager:\r\n    """Ensures safe operation during failures"""\r\n\r\n    def __init__(self, failure_coordinator: FailureHandlingCoordinator):\r\n        self.failure_coordinator = failure_coordinator\r\n        self.safety_zones = []  # Defined safe areas\r\n        self.emergency_stop_active = False\r\n        self.safe_position = None\r\n\r\n    def activate_emergency_stop(self):\r\n        """Activate emergency stop"""\r\n        if not self.emergency_stop_active:\r\n            self.emergency_stop_active = True\r\n            rospy.logerr("EMERGENCY STOP ACTIVATED")\r\n\r\n            # Stop all motion\r\n            self._stop_all_motion()\r\n\r\n            # Report to failure coordinator\r\n            self.failure_coordinator.handle_component_error(\r\n                \'safety_system\',\r\n                \'Emergency stop activated\',\r\n                ErrorLevel.FATAL\r\n            )\r\n\r\n    def deactivate_emergency_stop(self):\r\n        """Deactivate emergency stop"""\r\n        self.emergency_stop_active = False\r\n        rospy.loginfo("Emergency stop deactivated")\r\n\r\n    def _stop_all_motion(self):\r\n        """Stop all robot motion"""\r\n        # Stop base motion\r\n        cmd_vel_pub = rospy.Publisher(\'/cmd_vel\', Twist, queue_size=1, latch=True)\r\n        stop_cmd = Twist()\r\n        cmd_vel_pub.publish(stop_cmd)\r\n\r\n        # Stop manipulator (if present)\r\n        try:\r\n            # This would interface with manipulator controllers\r\n            pass\r\n        except:\r\n            pass\r\n\r\n        # Log the stop action\r\n        rospy.loginfo("All motion stopped due to safety system")\r\n\r\n    def check_safety_conditions(self):\r\n        """Check safety conditions and take action if needed"""\r\n        if self.emergency_stop_active:\r\n            return False  # No operations allowed during emergency stop\r\n\r\n        # Check for safety-critical errors\r\n        system_status = self.failure_coordinator.system_monitor.get_system_status()\r\n\r\n        if system_status[\'overall_status\'] == ComponentStatus.FATAL:\r\n            self.activate_emergency_stop()\r\n            return False\r\n\r\n        return True\r\n\r\n    def move_to_safe_position(self):\r\n        """Move robot to a predefined safe position"""\r\n        if self.safe_position:\r\n            rospy.loginfo(f"Moving to safe position: {self.safe_position}")\r\n            # This would interface with navigation system\r\n            # navigation_client.send_goal(self.safe_position)\r\n            return True\r\n        else:\r\n            rospy.logwarn("No safe position defined")\r\n            return False\r\n\r\n    def define_safe_position(self, position):\r\n        """Define a safe position for emergency situations"""\r\n        self.safe_position = position\r\n        rospy.loginfo(f"Safe position defined as: {position}")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-set-up-failure-handling-infrastructure",children:"Step 1: Set up Failure Handling Infrastructure"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Create the main failure handling node:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\nimport rospy\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Twist\r\nfrom sensor_msgs.msg import JointState\r\nimport json\r\nimport threading\r\nimport time\r\n\r\nclass FailureHandlingNode:\r\n    def __init__(self):\r\n        rospy.init_node('failure_handling_node')\r\n        rospy.set_param('start_time', rospy.get_time())\r\n\r\n        # Initialize failure handling components\r\n        self.failure_coordinator = FailureHandlingCoordinator()\r\n        self.safe_manager = SafeOperationManager(self.failure_coordinator)\r\n\r\n        # Setup publishers and subscribers\r\n        self.error_sub = rospy.Subscriber('/error_input', String, self.error_callback)\r\n        self.heartbeat_sub = rospy.Subscriber('/component_heartbeat', String, self.heartbeat_callback)\r\n        self.emergency_stop_sub = rospy.Subscriber('/emergency_stop', String, self.emergency_stop_callback)\r\n        self.safety_pub = rospy.Publisher('/safety_status', String, queue_size=10)\r\n\r\n        # Register this node for monitoring\r\n        self.failure_coordinator.system_monitor.register_component('failure_handling', timeout=10.0)\r\n\r\n        rospy.loginfo(\"Failure handling system initialized\")\r\n\r\n    def error_callback(self, msg):\r\n        \"\"\"Handle incoming error messages\"\"\"\r\n        try:\r\n            error_data = json.loads(msg.data)\r\n            component = error_data.get('component', 'unknown')\r\n            message = error_data.get('message', 'Unknown error')\r\n            level_str = error_data.get('level', 'ERROR')\r\n\r\n            # Convert level string to enum\r\n            try:\r\n                level = ErrorLevel[level_str.upper()]\r\n            except KeyError:\r\n                level = ErrorLevel.ERROR\r\n\r\n            rospy.loginfo(f\"Received error from {component}: {message}\")\r\n\r\n            # Handle the error through coordinator\r\n            success = self.failure_coordinator.handle_component_error(component, message, level)\r\n\r\n            # Publish safety status\r\n            safety_status = String()\r\n            safety_status.data = json.dumps({\r\n                'timestamp': rospy.get_time(),\r\n                'error_handled': success,\r\n                'component': component,\r\n                'message': message\r\n            })\r\n            self.safety_pub.publish(safety_status)\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error processing error callback: {e}\")\r\n\r\n    def heartbeat_callback(self, msg):\r\n        \"\"\"Handle component heartbeat\"\"\"\r\n        try:\r\n            heartbeat_data = json.loads(msg.data)\r\n            component = heartbeat_data.get('component', 'unknown')\r\n\r\n            self.failure_coordinator.component_heartbeat(component)\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error processing heartbeat: {e}\")\r\n\r\n    def emergency_stop_callback(self, msg):\r\n        \"\"\"Handle emergency stop requests\"\"\"\r\n        try:\r\n            emergency_data = json.loads(msg.data)\r\n            reason = emergency_data.get('reason', 'unknown')\r\n\r\n            rospy.logerr(f\"Emergency stop requested: {reason}\")\r\n            self.safe_manager.activate_emergency_stop()\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error processing emergency stop: {e}\")\r\n\r\n    def run(self):\r\n        \"\"\"Main execution loop\"\"\"\r\n        rate = rospy.Rate(10)  # 10 Hz\r\n\r\n        while not rospy.is_shutdown():\r\n            try:\r\n                # Check safety conditions\r\n                if not self.safe_manager.check_safety_conditions():\r\n                    rospy.logwarn(\"Safety conditions not met, pausing operations\")\r\n\r\n                # Send periodic heartbeat\r\n                self.failure_coordinator.component_heartbeat('failure_handling')\r\n\r\n                rate.sleep()\r\n\r\n            except Exception as e:\r\n                rospy.logerr(f\"Error in main loop: {e}\")\r\n                # Even if there's an error, try to continue\r\n\r\nif __name__ == '__main__':\r\n    failure_node = FailureHandlingNode()\r\n    try:\r\n        failure_node.run()\r\n    except rospy.ROSInterruptException:\r\n        rospy.loginfo(\"Failure handling node shutting down\")\r\n    except KeyboardInterrupt:\r\n        rospy.loginfo(\"Failure handling node interrupted\")\n"})}),"\n",(0,o.jsx)(e.h3,{id:"step-2-configure-failure-handling-parameters",children:"Step 2: Configure Failure Handling Parameters"}),"\n",(0,o.jsx)(e.p,{children:"Create a configuration file for failure handling parameters:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# failure_handling_params.yaml\r\nfailure_handling_node:\r\n  ros__parameters:\r\n    heartbeat_timeout: 5.0\r\n    error_debounce_time: 1.0\r\n    max_error_history: 100\r\n    degradation_thresholds:\r\n      warning: 3\r\n      safe_mode: 5\r\n      emergency_stop: 8\r\n    recovery_attempts: 3\r\n    retry_base_delay: 1.0\r\n    emergency_stop_topic: "/emergency_stop"\r\n    system_status_topic: "/system_status"\r\n    error_input_topic: "/error_input"\r\n\r\ndegradation_manager:\r\n  ros__parameters:\r\n    full_functional_threshold: 0\r\n    partial_functional_threshold: 3\r\n    safe_mode_threshold: 5\r\n    emergency_stop_threshold: 8\r\n\r\nrecovery_manager:\r\n  ros__parameters:\r\n    max_retries: 3\r\n    base_delay: 1.0\r\n    exponential_backoff_factor: 2.0\n'})}),"\n",(0,o.jsx)(e.h3,{id:"step-3-implement-component-specific-error-handlers",children:"Step 3: Implement Component-Specific Error Handlers"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class NavigationErrorHandler:\r\n    """Error handler for navigation system"""\r\n\r\n    def __init__(self, failure_coordinator):\r\n        self.failure_coordinator = failure_coordinator\r\n        self.nav_error_count = 0\r\n        self.consecutive_failures = 0\r\n\r\n    def handle_navigation_error(self, error_msg, error_type):\r\n        """Handle navigation-specific errors"""\r\n        self.nav_error_count += 1\r\n\r\n        if "local minimum" in error_msg.lower():\r\n            # Local minimum - try recovery behaviors\r\n            self._handle_local_minimum()\r\n        elif "obstacle" in error_msg.lower():\r\n            # Obstacle - try alternative path\r\n            self._handle_obstacle_error()\r\n        elif "goal unreachable" in error_msg.lower():\r\n            # Goal unreachable - report to user\r\n            self._handle_unreachable_goal()\r\n        elif "transform" in error_msg.lower():\r\n            # Transform error - likely localization issue\r\n            self._handle_transform_error()\r\n        else:\r\n            # General navigation error\r\n            pass\r\n\r\n        # Report to main failure coordinator\r\n        self.failure_coordinator.handle_component_error(\r\n            \'navigation\', error_msg, ErrorLevel.WARN\r\n        )\r\n\r\n    def _handle_local_minimum(self):\r\n        """Handle local minimum navigation failure"""\r\n        rospy.loginfo("Attempting to escape local minimum")\r\n        # This would trigger recovery behaviors like spinning or backing up\r\n        pass\r\n\r\n    def _handle_obstacle_error(self):\r\n        """Handle obstacle-related navigation errors"""\r\n        rospy.loginfo("Replanning to avoid obstacle")\r\n        # This would trigger replanning with updated costmap\r\n        pass\r\n\r\n    def _handle_unreachable_goal(self):\r\n        """Handle unreachable goal errors"""\r\n        rospy.loginfo("Goal appears unreachable, reporting to user")\r\n        # This would trigger user notification\r\n        pass\r\n\r\n    def _handle_transform_error(self):\r\n        """Handle transform/TF errors"""\r\n        rospy.loginfo("Transform error detected, checking localization")\r\n        # This would trigger localization recovery\r\n        pass\r\n\r\nclass ManipulationErrorHandler:\r\n    """Error handler for manipulation system"""\r\n\r\n    def __init__(self, failure_coordinator):\r\n        self.failure_coordinator = failure_coordinator\r\n        self.manip_error_count = 0\r\n\r\n    def handle_manipulation_error(self, error_msg, error_type):\r\n        """Handle manipulation-specific errors"""\r\n        self.manip_error_count += 1\r\n\r\n        if "grasp failed" in error_msg.lower():\r\n            self._handle_grasp_failure()\r\n        elif "collision" in error_msg.lower():\r\n            self._handle_collision_error()\r\n        elif "joint limit" in error_msg.lower():\r\n            self._handle_joint_limit_error()\r\n        elif "ik solution" in error_msg.lower():\r\n            self._handle_ik_error()\r\n        else:\r\n            # General manipulation error\r\n            pass\r\n\r\n        # Report to main failure coordinator\r\n        self.failure_coordinator.handle_component_error(\r\n            \'manipulation\', error_msg, ErrorLevel.WARN\r\n        )\r\n\r\n    def _handle_grasp_failure(self):\r\n        """Handle grasp failure"""\r\n        rospy.loginfo("Grasp failed, trying alternative grasp")\r\n        # This would trigger grasp re-planning\r\n        pass\r\n\r\n    def _handle_collision_error(self):\r\n        """Handle collision during manipulation"""\r\n        rospy.logerr("Collision detected during manipulation, stopping")\r\n        # This would trigger emergency stop for manipulator\r\n        pass\r\n\r\n    def _handle_joint_limit_error(self):\r\n        """Handle joint limit errors"""\r\n        rospy.logwarn("Joint limit exceeded, adjusting trajectory")\r\n        # This would trigger trajectory adjustment\r\n        pass\r\n\r\n    def _handle_ik_error(self):\r\n        """Handle inverse kinematics errors"""\r\n        rospy.logwarn("No IK solution found, adjusting goal pose")\r\n        # This would trigger goal pose adjustment\r\n        pass\r\n\r\nclass PerceptionErrorHandler:\r\n    """Error handler for perception system"""\r\n\r\n    def __init__(self, failure_coordinator):\r\n        self.failure_coordinator = failure_coordinator\r\n        self.percept_error_count = 0\r\n\r\n    def handle_perception_error(self, error_msg, error_type):\r\n        """Handle perception-specific errors"""\r\n        self.percept_error_count += 1\r\n\r\n        if "no detections" in error_msg.lower():\r\n            self._handle_no_detections()\r\n        elif "calibration" in error_msg.lower():\r\n            self._handle_calibration_error()\r\n        elif "depth" in error_msg.lower():\r\n            self._handle_depth_error()\r\n        elif "occlusion" in error_msg.lower():\r\n            self._handle_occlusion_error()\r\n        else:\r\n            # General perception error\r\n            pass\r\n\r\n        # Report to main failure coordinator\r\n        self.failure_coordinator.handle_component_error(\r\n            \'perception\', error_msg, ErrorLevel.WARN\r\n        )\r\n\r\n    def _handle_no_detections(self):\r\n        """Handle case where no objects are detected"""\r\n        rospy.loginfo("No objects detected, suggesting environment change or repositioning")\r\n        # This might trigger navigation to a different viewpoint\r\n        pass\r\n\r\n    def _handle_calibration_error(self):\r\n        """Handle sensor calibration errors"""\r\n        rospy.logerr("Sensor calibration error detected, stopping perception system")\r\n        # This would require manual recalibration\r\n        pass\r\n\r\n    def _handle_depth_error(self):\r\n        """Handle depth sensing errors"""\r\n        rospy.logwarn("Depth sensing issues detected, using alternative methods")\r\n        # This might switch to stereo or structured light methods\r\n        pass\r\n\r\n    def _handle_occlusion_error(self):\r\n        """Handle object occlusion"""\r\n        rospy.loginfo("Object occluded, trying different viewpoint")\r\n        # This would trigger repositioning for better view\r\n        pass\n'})}),"\n",(0,o.jsx)(e.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,o.jsx)(e.h3,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import unittest\r\nfrom unittest.mock import Mock, patch\r\n\r\nclass TestComponentMonitor(unittest.TestCase):\r\n    def setUp(self):\r\n        self.monitor = ComponentMonitor("test_component", timeout=2.0)\r\n\r\n    def test_heartbeat_updates_status(self):\r\n        """Test that heartbeat updates component status"""\r\n        initial_status = self.monitor.get_status()\r\n        self.assertEqual(initial_status, ComponentStatus.OK)\r\n\r\n        # Simulate heartbeat\r\n        self.monitor.heartbeat()\r\n        time.sleep(0.1)  # Allow for thread synchronization\r\n\r\n        status_after_heartbeat = self.monitor.get_status()\r\n        self.assertEqual(status_after_heartbeat, ComponentStatus.OK)\r\n\r\n    def test_timeout_detection(self):\r\n        """Test that component timeout is detected"""\r\n        # Set heartbeat to a time in the past\r\n        self.monitor.last_heartbeat = rospy.get_time() - 5.0  # 5 seconds ago\r\n\r\n        self.assertFalse(self.monitor.is_alive())\r\n        self.assertEqual(self.monitor.get_status(), ComponentStatus.ERROR)\r\n\r\n    def test_error_reporting(self):\r\n        """Test error reporting functionality"""\r\n        self.monitor.report_error("Test error", ErrorLevel.ERROR, ErrorType.SOFTWARE)\r\n\r\n        status = self.monitor.get_status()\r\n        self.assertEqual(status, ComponentStatus.ERROR)\r\n\r\n        error_count = self.monitor.get_error_count(ErrorLevel.ERROR)\r\n        self.assertEqual(error_count, 1)\r\n\r\nclass TestErrorClassifier(unittest.TestCase):\r\n    def setUp(self):\r\n        self.classifier = ErrorClassifier()\r\n\r\n    def test_communication_error_classification(self):\r\n        """Test classification of communication errors"""\r\n        error_type, error_level = self.classifier.classify_error("Connection refused to server")\r\n        self.assertEqual(error_type, ErrorType.COMMUNICATION)\r\n        self.assertEqual(error_level, ErrorLevel.ERROR)\r\n\r\n    def test_hardware_error_classification(self):\r\n        """Test classification of hardware errors"""\r\n        error_type, error_level = self.classifier.classify_error("Motor fault detected")\r\n        self.assertEqual(error_type, ErrorType.HARDWARE)\r\n        self.assertEqual(error_level, ErrorLevel.ERROR)\r\n\r\n    def test_safety_error_classification(self):\r\n        """Test classification of safety errors"""\r\n        error_type, error_level = self.classifier.classify_error("Collision detected")\r\n        self.assertEqual(error_type, ErrorType.SAFETY)\r\n        self.assertEqual(error_level, ErrorLevel.ERROR)\r\n\r\nclass TestRecoveryManager(unittest.TestCase):\r\n    def setUp(self):\r\n        self.recovery_manager = RecoveryManager()\r\n\r\n    def test_emergency_stop_strategy(self):\r\n        """Test emergency stop strategy selection"""\r\n        error_context = {\r\n            \'error_message\': "collision detected",\r\n            \'error_type\': ErrorType.SAFETY,\r\n            \'component\': \'navigation\'\r\n        }\r\n\r\n        # This should select the emergency stop strategy first\r\n        options = self.recovery_manager.get_recovery_options(error_context)\r\n        self.assertIn(\'emergency_stop\', options)\r\n\r\n    def test_retry_strategy_applicability(self):\r\n        """Test that retry strategy applies to appropriate errors"""\r\n        error_context = {\r\n            \'error_message\': "connection timeout",\r\n            \'error_type\': ErrorType.COMMUNICATION,\r\n            \'component\': \'perception\'\r\n        }\r\n\r\n        options = self.recovery_manager.get_recovery_options(error_context)\r\n        self.assertIn(\'retry\', options)\r\n\r\nclass TestDegradationManager(unittest.TestCase):\r\n    def setUp(self):\r\n        self.degradation_manager = DegradationManager()\r\n\r\n    def test_degradation_level_calculation(self):\r\n        """Test degradation level calculation"""\r\n        # Test full functional level (no errors)\r\n        level = self.degradation_manager.update_degradation_level(0)\r\n        self.assertEqual(level, DegradationLevel.FULL_FUNCTIONAL)\r\n\r\n        # Test safe mode level (medium errors)\r\n        level = self.degradation_manager.update_degradation_level(6)\r\n        self.assertEqual(level, DegradationLevel.SAFE_MODE)\r\n\r\n        # Test emergency stop level (high errors)\r\n        level = self.degradation_manager.update_degradation_level(10)\r\n        self.assertEqual(level, DegradationLevel.EMERGENCY_STOP)\r\n\r\n    def test_functionality_check(self):\r\n        """Test functionality availability checking"""\r\n        # Set to safe mode\r\n        self.degradation_manager.update_degradation_level(6)\r\n\r\n        # In safe mode, navigation should be available but manipulation should not\r\n        self.assertTrue(self.degradation_manager.is_functionality_available(\'navigation\'))\r\n        self.assertFalse(self.degradation_manager.is_functionality_available(\'manipulation\'))\r\n\r\nif __name__ == \'__main__\':\r\n    unittest.main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class FailureHandlingIntegrationTest:\r\n    def __init__(self):\r\n        rospy.init_node(\'failure_handling_integration_test\')\r\n        self.coordinator = FailureHandlingCoordinator()\r\n\r\n    def test_error_propagation(self):\r\n        """Test complete error handling pipeline"""\r\n        print("Testing error propagation...")\r\n\r\n        # Simulate errors from different components\r\n        errors_to_test = [\r\n            ("navigation", "obstacle detected", ErrorLevel.WARN),\r\n            ("manipulation", "grasp failed", ErrorLevel.WARN),\r\n            ("perception", "no objects detected", ErrorLevel.WARN),\r\n            ("navigation", "goal unreachable", ErrorLevel.ERROR),\r\n        ]\r\n\r\n        for component, error_msg, error_level in errors_to_test:\r\n            print(f"Injecting error: {component} - {error_msg}")\r\n            success = self.coordinator.handle_component_error(component, error_msg, error_level)\r\n            print(f"Recovery success: {success}")\r\n\r\n        # Check system status after errors\r\n        health_summary = self.coordinator.get_system_health_summary()\r\n        print(f"System health after errors: {health_summary[\'system_status\'][\'overall_status\']}")\r\n\r\n    def test_degradation_behavior(self):\r\n        """Test system degradation behavior"""\r\n        print("Testing degradation behavior...")\r\n\r\n        # Simulate increasing number of errors\r\n        for i in range(10):\r\n            self.coordinator.handle_component_error(\r\n                f"component_{i}",\r\n                f"simulated error {i}",\r\n                ErrorLevel.WARN\r\n            )\r\n\r\n            # Check current degradation level\r\n            current_level = self.coordinator.degradation_manager.current_level\r\n            print(f"After {i+1} errors: {current_level.value}")\r\n\r\n    def test_recovery_sequence(self):\r\n        """Test recovery strategy sequence"""\r\n        print("Testing recovery sequence...")\r\n\r\n        # Simulate a communication error that should trigger retry\r\n        success = self.coordinator.handle_component_error(\r\n            "perception",\r\n            "connection timeout to camera",\r\n            ErrorLevel.ERROR\r\n        )\r\n        print(f"Communication error recovery success: {success}")\r\n\r\n        # Simulate a safety error that should trigger emergency stop\r\n        success = self.coordinator.handle_component_error(\r\n            "navigation",\r\n            "collision detected",\r\n            ErrorLevel.FATAL\r\n        )\r\n        print(f"Safety error recovery success: {success}")\r\n\r\n    def test_user_notification(self):\r\n        """Test user notification system"""\r\n        print("Testing user notification...")\r\n\r\n        # Simulate an error and check if user is notified\r\n        self.coordinator.handle_component_error(\r\n            "manipulation",\r\n            "grasp failed after 3 attempts",\r\n            ErrorLevel.ERROR\r\n        )\r\n\r\n        print("User notification test completed")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,o.jsx)(e.h3,{id:"failure-handling-performance",children:"Failure Handling Performance"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Error Detection"}),": < 10ms for local error detection"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Error Classification"}),": < 5ms per error message"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Strategy Selection"}),": < 20ms for strategy evaluation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"System Status Updates"}),": < 100ms for comprehensive status"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Memory Usage"}),": < 50MB for full failure handling system"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"reliability-metrics",children:"Reliability Metrics"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Error Detection Rate"}),": > 99% for critical errors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Success Rate"}),": > 85% for common error types"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"False Positive Rate"}),": < 1% for error classification"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"System Availability"}),": > 95% under normal operating conditions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Mean Time To Recovery"}),": < 30 seconds for most errors"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-and-common-issues",children:"Troubleshooting and Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"error-detection-problems",children:"Error Detection Problems"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"False Positives"}),": Adjust error pattern matching and confidence thresholds"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Missed Errors"}),": Improve error reporting from components"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Timing Issues"}),": Ensure proper heartbeat intervals and timeouts"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Resource Overhead"}),": Optimize monitoring frequency and data collection"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"recovery-problems",children:"Recovery Problems"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Failed Recoveries"}),": Implement more robust recovery strategies"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Infinite Loops"}),": Add recovery attempt limits and escalation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Partial Recovery"}),": Ensure system returns to known safe state"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Conflicts"}),": Coordinate between multiple recovery attempts"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Defense in Depth"}),": Multiple layers of safety checks"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fail-Safe"}),": Ensure safe state when errors occur"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Graceful Degradation"}),": Maintain basic functionality during errors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Emergency Procedures"}),": Clear protocols for critical failures"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Selective Monitoring"}),": Monitor only critical components"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Efficient Classification"}),": Use fast pattern matching algorithms"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Caching"}),": Cache frequently accessed data"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Threading"}),": Use separate threads for monitoring and recovery"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"maintainability",children:"Maintainability"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Clear Logging"}),": Comprehensive and structured error logging"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Configuration"}),": Use parameters for easy tuning"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Modularity"}),": Keep components loosely coupled"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Documentation"}),": Maintain clear recovery procedure documentation"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps-and-integration",children:"Next Steps and Integration"}),"\n",(0,o.jsx)(e.h3,{id:"integration-with-other-capstone-components",children:"Integration with Other Capstone Components"}),"\n",(0,o.jsx)(e.p,{children:"The failure handling system integrates with:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"All Components"}),": Provides monitoring and error handling"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Navigation"}),": Handles navigation-specific failures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Manipulation"}),": Manages manipulation errors and safety"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Perception"}),": Deals with sensor and detection failures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Task Planning"}),": Adjusts plans when failures occur"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Voice Processing"}),": Maintains communication despite errors"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,o.jsx)(e.p,{children:"Consider implementing:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Predictive Maintenance"}),": Predict failures before they occur"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Machine Learning"}),": Learn from error patterns to improve recovery"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Distributed Handling"}),": Handle failures across multiple robots"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Automated Diagnostics"}),": Self-diagnose and repair capabilities"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["Continue with ",(0,o.jsx)(e.a,{href:"/Book-ai-native/docs/capstone/integration",children:"End-to-End Integration Guide"})," to explore how all capstone components work together in a cohesive system and how to ensure seamless integration across all modules."]}),"\n",(0,o.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,o.jsx)(e.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function _(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(d,{...r})}):d(r)}}}]);