"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[1861],{411(n,r,e){e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-ai-brain/path-planning","title":"Path Planning Algorithm Implementation","description":"Learning Objectives","source":"@site/docs/module-3-ai-brain/path-planning.md","sourceDirName":"module-3-ai-brain","slug":"/module-3-ai-brain/path-planning","permalink":"/Book-ai-native/docs/module-3-ai-brain/path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/module-3-ai-brain/path-planning.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Neural Network Inference Optimization","permalink":"/Book-ai-native/docs/module-3-ai-brain/inference-optimization"},"next":{"title":"Manipulation Control Systems","permalink":"/Book-ai-native/docs/module-3-ai-brain/manipulation-control"}}');var i=e(4848),a=e(8453);const o={sidebar_position:5},s="Path Planning Algorithm Implementation",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Path Planning",id:"introduction-to-path-planning",level:2},{value:"Configuration Space and Representation",id:"configuration-space-and-representation",level:2},{value:"Environment Representation",id:"environment-representation",level:3},{value:"Occupancy Grids",id:"occupancy-grids",level:3},{value:"Classical Path Planning Algorithms",id:"classical-path-planning-algorithms",level:2},{value:"A* Algorithm",id:"a-algorithm",level:3},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"Sampling-Based Planning: RRT",id:"sampling-based-planning-rrt",level:2},{value:"Integration with ROS 2 and Isaac",id:"integration-with-ros-2-and-isaac",level:2},{value:"Isaac ROS Navigation Integration",id:"isaac-ros-navigation-integration",level:3},{value:"Motion Planning for Manipulation",id:"motion-planning-for-manipulation",level:2},{value:"Configuration Space for Manipulators",id:"configuration-space-for-manipulators",level:3},{value:"Dynamic Path Planning and Replanning",id:"dynamic-path-planning-and-replanning",level:2},{value:"Handling Moving Obstacles",id:"handling-moving-obstacles",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Path Smoothing",id:"path-smoothing",level:3},{value:"Multi-Resolution Planning",id:"multi-resolution-planning",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(n){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"path-planning-algorithm-implementation",children:"Path Planning Algorithm Implementation"})}),"\n",(0,i.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(r.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Implement classical path planning algorithms (A*, Dijkstra, RRT)"}),"\n",(0,i.jsx)(r.li,{children:"Design motion planning systems for robotic navigation"}),"\n",(0,i.jsx)(r.li,{children:"Integrate path planning with perception and control systems"}),"\n",(0,i.jsx)(r.li,{children:"Optimize planning algorithms for real-time performance"}),"\n",(0,i.jsx)(r.li,{children:"Handle dynamic obstacles and replanning scenarios"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"introduction-to-path-planning",children:"Introduction to Path Planning"}),"\n",(0,i.jsx)(r.p,{children:"Path planning is a fundamental capability for autonomous robots, enabling them to navigate from a start position to a goal position while avoiding obstacles and respecting kinematic constraints. In the context of AI-powered robots, path planning bridges the gap between perception (understanding the environment) and control (executing movement)."}),"\n",(0,i.jsx)(r.p,{children:"Path planning algorithms can be categorized into several types:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Global planners"}),": Compute paths using a complete map of the environment"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Local planners"}),": Generate short-term paths based on immediate sensor data"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Sampling-based planners"}),": Use random sampling to explore configuration space"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Optimization-based planners"}),": Formulate path planning as an optimization problem"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"configuration-space-and-representation",children:"Configuration Space and Representation"}),"\n",(0,i.jsx)(r.h3,{id:"environment-representation",children:"Environment Representation"}),"\n",(0,i.jsx)(r.p,{children:"Robots operate in a configuration space (C-space) where each point represents a possible state of the robot. For path planning, we typically represent the environment as:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Discrete grid maps"}),": 2D or 3D grids with occupancy values"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Topological maps"}),": Graphs representing connectivity between locations"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Continuous spaces"}),": Mathematical representations of free space"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"occupancy-grids",children:"Occupancy Grids"}),"\n",(0,i.jsx)(r.p,{children:"Occupancy grids provide a probabilistic representation of the environment:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'import numpy as np\r\nfrom nav_msgs.msg import OccupancyGrid\r\nimport math\r\n\r\nclass OccupancyGridMap:\r\n    def __init__(self, resolution=0.05, width=100, height=100):\r\n        self.resolution = resolution  # meters per cell\r\n        self.width = width  # number of cells\r\n        self.height = height  # number of cells\r\n        self.origin_x = 0.0\r\n        self.origin_y = 0.0\r\n\r\n        # Initialize grid with unknown values (-1)\r\n        self.grid = np.full((height, width), -1, dtype=np.int8)\r\n\r\n    def world_to_grid(self, x_world, y_world):\r\n        """Convert world coordinates to grid coordinates"""\r\n        x_grid = int((x_world - self.origin_x) / self.resolution)\r\n        y_grid = int((y_world - self.origin_y) / self.resolution)\r\n        return x_grid, y_grid\r\n\r\n    def grid_to_world(self, x_grid, y_grid):\r\n        """Convert grid coordinates to world coordinates"""\r\n        x_world = x_grid * self.resolution + self.origin_x\r\n        y_world = y_grid * self.resolution + self.origin_y\r\n        return x_world, y_world\r\n\r\n    def is_occupied(self, x_grid, y_grid):\r\n        """Check if grid cell is occupied"""\r\n        if 0 <= x_grid < self.width and 0 <= y_grid < self.height:\r\n            return self.grid[y_grid, x_grid] > 50  # Occupied if probability > 50%\r\n        return True  # Out of bounds is considered occupied\r\n\r\n    def is_free(self, x_grid, y_grid):\r\n        """Check if grid cell is free"""\r\n        if 0 <= x_grid < self.width and 0 <= y_grid < self.height:\r\n            return self.grid[y_grid, x_grid] < 25  # Free if probability < 25%\r\n        return False\r\n\r\n    def get_neighbors(self, x, y):\r\n        """Get 8-connected neighbors of a grid cell"""\r\n        neighbors = []\r\n        for dx in [-1, 0, 1]:\r\n            for dy in [-1, 0, 1]:\r\n                if dx == 0 and dy == 0:\r\n                    continue\r\n                nx, ny = x + dx, y + dy\r\n                if 0 <= nx < self.width and 0 <= ny < self.height:\r\n                    neighbors.append((nx, ny))\r\n        return neighbors\n'})}),"\n",(0,i.jsx)(r.h2,{id:"classical-path-planning-algorithms",children:"Classical Path Planning Algorithms"}),"\n",(0,i.jsx)(r.h3,{id:"a-algorithm",children:"A* Algorithm"}),"\n",(0,i.jsx)(r.p,{children:"A* is a popular graph search algorithm that finds optimal paths by combining actual cost from start with heuristic cost to goal:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'import heapq\r\nfrom typing import List, Tuple\r\n\r\nclass AStarPlanner:\r\n    def __init__(self, occupancy_grid):\r\n        self.grid = occupancy_grid\r\n\r\n    def heuristic(self, pos1, pos2):\r\n        """Calculate heuristic distance (Euclidean)"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using A* algorithm"""\r\n        # Convert world coordinates to grid coordinates\r\n        start_grid = self.grid.world_to_grid(start[0], start[1])\r\n        goal_grid = self.grid.world_to_grid(goal[0], goal[1])\r\n\r\n        # Priority queue: (f_score, g_score, position)\r\n        open_set = [(0, 0, start_grid)]\r\n        closed_set = set()\r\n\r\n        # Cost dictionaries\r\n        g_score = {start_grid: 0}\r\n        came_from = {}\r\n\r\n        while open_set:\r\n            f_score, current_g, current = heapq.heappop(open_set)\r\n\r\n            # Check if we reached the goal\r\n            if current == goal_grid:\r\n                return self.reconstruct_path(came_from, current)\r\n\r\n            # Skip if already processed\r\n            if current in closed_set:\r\n                continue\r\n\r\n            closed_set.add(current)\r\n\r\n            # Process neighbors\r\n            for neighbor in self.grid.get_neighbors(current[0], current[1]):\r\n                if self.grid.is_occupied(neighbor[0], neighbor[1]):\r\n                    continue\r\n\r\n                # Calculate tentative g_score\r\n                tentative_g = current_g + self.calculate_distance(current, neighbor)\r\n\r\n                if neighbor in g_score and tentative_g >= g_score[neighbor]:\r\n                    continue\r\n\r\n                # This path to neighbor is better than any previous one\r\n                came_from[neighbor] = current\r\n                g_score[neighbor] = tentative_g\r\n                f_score = tentative_g + self.heuristic(neighbor, goal_grid)\r\n\r\n                heapq.heappush(open_set, (f_score, tentative_g, neighbor))\r\n\r\n        return None  # No path found\r\n\r\n    def calculate_distance(self, pos1, pos2):\r\n        """Calculate distance between adjacent grid cells"""\r\n        dx = pos1[0] - pos2[0]\r\n        dy = pos1[1] - pos2[1]\r\n        return math.sqrt(dx*dx + dy*dy)\r\n\r\n    def reconstruct_path(self, came_from, current):\r\n        """Reconstruct path from came_from dictionary"""\r\n        path = [current]\r\n        while current in came_from:\r\n            current = came_from[current]\r\n            path.append(current)\r\n        path.reverse()\r\n\r\n        # Convert grid coordinates back to world coordinates\r\n        world_path = []\r\n        for grid_pos in path:\r\n            world_pos = self.grid.grid_to_world(grid_pos[0], grid_pos[1])\r\n            world_path.append(world_pos)\r\n\r\n        return world_path\n'})}),"\n",(0,i.jsx)(r.h3,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,i.jsx)(r.p,{children:"Dijkstra's algorithm is similar to A* but uses uniform cost without heuristic:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'class DijkstraPlanner:\r\n    def __init__(self, occupancy_grid):\r\n        self.grid = occupancy_grid\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using Dijkstra\'s algorithm"""\r\n        start_grid = self.grid.world_to_grid(start[0], start[1])\r\n        goal_grid = self.grid.world_to_grid(goal[0], goal[1])\r\n\r\n        # Priority queue: (g_score, position)\r\n        open_set = [(0, start_grid)]\r\n        closed_set = set()\r\n\r\n        # Cost dictionary\r\n        g_score = {start_grid: 0}\r\n        came_from = {}\r\n\r\n        while open_set:\r\n            current_g, current = heapq.heappop(open_set)\r\n\r\n            if current == goal_grid:\r\n                return self.reconstruct_path(came_from, current)\r\n\r\n            if current in closed_set:\r\n                continue\r\n\r\n            closed_set.add(current)\r\n\r\n            for neighbor in self.grid.get_neighbors(current[0], current[1]):\r\n                if self.grid.is_occupied(neighbor[0], neighbor[1]):\r\n                    continue\r\n\r\n                tentative_g = current_g + self.calculate_distance(current, neighbor)\r\n\r\n                if neighbor in g_score and tentative_g >= g_score[neighbor]:\r\n                    continue\r\n\r\n                came_from[neighbor] = current\r\n                g_score[neighbor] = tentative_g\r\n\r\n                heapq.heappush(open_set, (tentative_g, neighbor))\r\n\r\n        return None\r\n\r\n    def calculate_distance(self, pos1, pos2):\r\n        """Calculate distance between adjacent grid cells"""\r\n        dx = pos1[0] - pos2[0]\r\n        dy = pos1[1] - pos2[1]\r\n        return math.sqrt(dx*dx + dy*dy)\r\n\r\n    def reconstruct_path(self, came_from, current):\r\n        """Reconstruct path from came_from dictionary"""\r\n        path = [current]\r\n        while current in came_from:\r\n            current = came_from[current]\r\n            path.append(current)\r\n        path.reverse()\r\n\r\n        # Convert grid coordinates back to world coordinates\r\n        world_path = []\r\n        for grid_pos in path:\r\n            world_pos = self.grid.grid_to_world(grid_pos[0], grid_pos[1])\r\n            world_path.append(world_pos)\r\n\r\n        return world_path\n'})}),"\n",(0,i.jsx)(r.h2,{id:"sampling-based-planning-rrt",children:"Sampling-Based Planning: RRT"}),"\n",(0,i.jsx)(r.p,{children:"Rapidly-exploring Random Trees (RRT) are particularly useful for high-dimensional configuration spaces:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'import random\r\n\r\nclass RRTNode:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n        self.parent = None\r\n\r\nclass RRTPlanner:\r\n    def __init__(self, occupancy_grid, step_size=0.5):\r\n        self.grid = occupancy_grid\r\n        self.step_size = step_size\r\n\r\n    def plan_path(self, start, goal, max_iterations=1000):\r\n        """Plan path using RRT algorithm"""\r\n        start_grid = self.grid.world_to_grid(start[0], start[1])\r\n        goal_grid = self.grid.world_to_grid(goal[0], goal[1])\r\n\r\n        start_node = RRTNode(start_grid[0], start_grid[1])\r\n        tree = [start_node]\r\n\r\n        for i in range(max_iterations):\r\n            # Sample random point\r\n            rand_x = random.randint(0, self.grid.width - 1)\r\n            rand_y = random.randint(0, self.grid.height - 1)\r\n\r\n            # Find nearest node in tree\r\n            nearest_node = self.find_nearest_node(tree, rand_x, rand_y)\r\n\r\n            # Extend towards random point\r\n            new_node = self.extend_towards(nearest_node, rand_x, rand_y)\r\n\r\n            if new_node and not self.is_collision(new_node):\r\n                new_node.parent = nearest_node\r\n                tree.append(new_node)\r\n\r\n                # Check if we\'re close to goal\r\n                if self.distance((new_node.x, new_node.y), goal_grid) < 5:  # 5 cells threshold\r\n                    return self.extract_path(new_node, start_node)\r\n\r\n        return None\r\n\r\n    def find_nearest_node(self, tree, x, y):\r\n        """Find the nearest node in the tree to the given coordinates"""\r\n        nearest = tree[0]\r\n        min_dist = self.distance((nearest.x, nearest.y), (x, y))\r\n\r\n        for node in tree:\r\n            dist = self.distance((node.x, node.y), (x, y))\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n                nearest = node\r\n\r\n        return nearest\r\n\r\n    def extend_towards(self, from_node, to_x, to_y):\r\n        """Extend the tree towards the target point"""\r\n        direction = math.atan2(to_y - from_node.y, to_x - from_node.x)\r\n        new_x = int(from_node.x + self.step_size * math.cos(direction))\r\n        new_y = int(from_node.y + self.step_size * math.sin(direction))\r\n\r\n        # Check bounds\r\n        if 0 <= new_x < self.grid.width and 0 <= new_y < self.grid.height:\r\n            return RRTNode(new_x, new_y)\r\n        return None\r\n\r\n    def is_collision(self, node):\r\n        """Check if the node is in collision"""\r\n        return self.grid.is_occupied(node.x, node.y)\r\n\r\n    def distance(self, pos1, pos2):\r\n        """Calculate Euclidean distance between two points"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def extract_path(self, goal_node, start_node):\r\n        """Extract path from goal node back to start"""\r\n        path = []\r\n        current = goal_node\r\n\r\n        while current != start_node:\r\n            path.append((current.x, current.y))\r\n            current = current.parent\r\n\r\n        path.append((start_node.x, start_node.y))\r\n        path.reverse()\r\n\r\n        # Convert grid coordinates back to world coordinates\r\n        world_path = []\r\n        for grid_pos in path:\r\n            world_pos = self.grid.grid_to_world(grid_pos[0], grid_pos[1])\r\n            world_path.append(world_pos)\r\n\r\n        return world_path\n'})}),"\n",(0,i.jsx)(r.h2,{id:"integration-with-ros-2-and-isaac",children:"Integration with ROS 2 and Isaac"}),"\n",(0,i.jsx)(r.h3,{id:"isaac-ros-navigation-integration",children:"Isaac ROS Navigation Integration"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides optimized navigation capabilities that can be integrated with path planning:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import Path, OccupancyGrid\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\n\r\nclass IsaacPathPlannerNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_path_planner\')\r\n\r\n        # Publishers\r\n        self.path_publisher = self.create_publisher(Path, \'planned_path\', 10)\r\n        self.visualization_publisher = self.create_publisher(MarkerArray, \'path_visualization\', 10)\r\n\r\n        # Subscribers\r\n        self.map_subscription = self.create_subscription(\r\n            OccupancyGrid,\r\n            \'map\',\r\n            self.map_callback,\r\n            10\r\n        )\r\n\r\n        self.goal_subscription = self.create_subscription(\r\n            PoseStamped,\r\n            \'goal_pose\',\r\n            self.goal_callback,\r\n            10\r\n        )\r\n\r\n        self.laser_subscription = self.create_subscription(\r\n            LaserScan,\r\n            \'scan\',\r\n            self.laser_callback,\r\n            10\r\n        )\r\n\r\n        # Initialize planners\r\n        self.occupancy_grid = None\r\n        self.a_star_planner = None\r\n        self.current_goal = None\r\n\r\n    def map_callback(self, msg):\r\n        """Handle incoming map message"""\r\n        self.occupancy_grid = self.convert_occupancy_grid(msg)\r\n        self.a_star_planner = AStarPlanner(self.occupancy_grid)\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle incoming goal pose"""\r\n        if self.a_star_planner:\r\n            self.current_goal = (msg.pose.position.x, msg.pose.position.y)\r\n\r\n            # Plan path from current position to goal\r\n            current_pos = self.get_current_position()  # Implementation needed\r\n            path = self.a_star_planner.plan_path(current_pos, self.current_goal)\r\n\r\n            if path:\r\n                self.publish_path(path)\r\n                self.visualize_path(path)\r\n\r\n    def laser_callback(self, msg):\r\n        """Handle laser scan for local obstacle avoidance"""\r\n        # Update local map with laser scan data\r\n        # This would integrate with local planner for dynamic obstacle avoidance\r\n        pass\r\n\r\n    def convert_occupancy_grid(self, ros_grid_msg):\r\n        """Convert ROS OccupancyGrid message to our format"""\r\n        grid = OccupancyGridMap(\r\n            resolution=ros_grid_msg.info.resolution,\r\n            width=ros_grid_msg.info.width,\r\n            height=ros_grid_msg.info.height\r\n        )\r\n\r\n        # Convert ROS grid data to our format\r\n        grid.grid = np.array(ros_grid_msg.data).reshape((grid.height, grid.width))\r\n        grid.origin_x = ros_grid_msg.info.origin.position.x\r\n        grid.origin_y = ros_grid_msg.info.origin.position.y\r\n\r\n        return grid\r\n\r\n    def publish_path(self, path):\r\n        """Publish planned path as ROS Path message"""\r\n        path_msg = Path()\r\n        path_msg.header.stamp = self.get_clock().now().to_msg()\r\n        path_msg.header.frame_id = \'map\'\r\n\r\n        for point in path:\r\n            pose = PoseStamped()\r\n            pose.pose.position.x = point[0]\r\n            pose.pose.position.y = point[1]\r\n            pose.pose.position.z = 0.0\r\n            pose.pose.orientation.w = 1.0  # No rotation\r\n            path_msg.poses.append(pose)\r\n\r\n        self.path_publisher.publish(path_msg)\r\n\r\n    def visualize_path(self, path):\r\n        """Visualize path in RViz"""\r\n        marker_array = MarkerArray()\r\n\r\n        # Create line strip marker for path\r\n        line_marker = Marker()\r\n        line_marker.header.frame_id = \'map\'\r\n        line_marker.header.stamp = self.get_clock().now().to_msg()\r\n        line_marker.ns = \'path\'\r\n        line_marker.id = 0\r\n        line_marker.type = Marker.LINE_STRIP\r\n        line_marker.action = Marker.ADD\r\n        line_marker.scale.x = 0.05  # Line width\r\n        line_marker.color.r = 0.0\r\n        line_marker.color.g = 1.0\r\n        line_marker.color.b = 0.0\r\n        line_marker.color.a = 1.0\r\n\r\n        for point in path:\r\n            p = Point()\r\n            p.x = point[0]\r\n            p.y = point[1]\r\n            p.z = 0.0\r\n            line_marker.points.append(p)\r\n\r\n        marker_array.markers.append(line_marker)\r\n        self.visualization_publisher.publish(marker_array)\r\n\r\n    def get_current_position(self):\r\n        """Get current robot position - implementation depends on localization system"""\r\n        # This would typically interface with AMCL or other localization\r\n        # For now, return a placeholder\r\n        return (0.0, 0.0)\n'})}),"\n",(0,i.jsx)(r.h2,{id:"motion-planning-for-manipulation",children:"Motion Planning for Manipulation"}),"\n",(0,i.jsx)(r.h3,{id:"configuration-space-for-manipulators",children:"Configuration Space for Manipulators"}),"\n",(0,i.jsx)(r.p,{children:"Motion planning for robotic arms requires planning in joint space rather than Cartesian space:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\n\r\nclass ManipulatorPathPlanner:\r\n    def __init__(self, robot_model):\r\n        self.robot = robot_model\r\n        self.joint_limits = robot_model.get_joint_limits()\r\n\r\n    def plan_manipulation_path(self, start_joints, goal_pose, obstacles=None):\r\n        """Plan path for manipulator from start joint configuration to goal pose"""\r\n        # Convert goal pose to joint space using inverse kinematics\r\n        goal_joints = self.inverse_kinematics(goal_pose)\r\n\r\n        if goal_joints is None:\r\n            return None  # No valid IK solution\r\n\r\n        # Plan path in joint space\r\n        path = self.plan_joint_space_path(start_joints, goal_joints, obstacles)\r\n        return path\r\n\r\n    def inverse_kinematics(self, target_pose):\r\n        """Calculate inverse kinematics to find joint angles for target pose"""\r\n        # This would use robot-specific IK solver\r\n        # For demonstration, return a simple approximation\r\n        pass\r\n\r\n    def plan_joint_space_path(self, start_joints, goal_joints, obstacles):\r\n        """Plan path in joint space"""\r\n        # Use RRT or other sampling-based method in joint space\r\n        path = []\r\n\r\n        # Linear interpolation in joint space as a simple approach\r\n        steps = 50\r\n        for i in range(steps + 1):\r\n            t = i / steps\r\n            joints = []\r\n            for start, goal in zip(start_joints, goal_joints):\r\n                joint_val = start + t * (goal - start)\r\n                joints.append(joint_val)\r\n\r\n            # Check collision for this configuration\r\n            if not self.check_collision(joints, obstacles):\r\n                path.append(joints)\r\n\r\n        return path\r\n\r\n    def check_collision(self, joint_config, obstacles):\r\n        """Check if joint configuration results in collision"""\r\n        # Calculate link positions using forward kinematics\r\n        link_positions = self.forward_kinematics(joint_config)\r\n\r\n        # Check collision with obstacles\r\n        for link_pos in link_positions:\r\n            for obstacle in obstacles:\r\n                if self.distance(link_pos, obstacle) < self.robot.link_radius:\r\n                    return True\r\n        return False\r\n\r\n    def forward_kinematics(self, joint_config):\r\n        """Calculate forward kinematics to get link positions"""\r\n        # This would use robot-specific FK solver\r\n        pass\r\n\r\n    def distance(self, pos1, pos2):\r\n        """Calculate distance between two points"""\r\n        return np.linalg.norm(np.array(pos1) - np.array(pos2))\n'})}),"\n",(0,i.jsx)(r.h2,{id:"dynamic-path-planning-and-replanning",children:"Dynamic Path Planning and Replanning"}),"\n",(0,i.jsx)(r.h3,{id:"handling-moving-obstacles",children:"Handling Moving Obstacles"}),"\n",(0,i.jsx)(r.p,{children:"Real-world environments contain moving obstacles that require replanning:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'class DynamicPathPlanner:\r\n    def __init__(self, base_planner):\r\n        self.base_planner = base_planner\r\n        self.current_path = None\r\n        self.path_index = 0\r\n        self.last_replan_time = 0\r\n        self.replan_interval = 1.0  # seconds\r\n\r\n    def update_and_follow_path(self, current_pose, dynamic_obstacles):\r\n        """Update path based on dynamic obstacles and follow current path"""\r\n        current_time = time.time()\r\n\r\n        # Check if we need to replan\r\n        if self.should_replan(current_pose, dynamic_obstacles, current_time):\r\n            new_path = self.base_planner.plan_path(\r\n                current_pose,\r\n                self.goal,\r\n                dynamic_obstacles\r\n            )\r\n\r\n            if new_path:\r\n                self.current_path = new_path\r\n                self.path_index = self.find_closest_path_point(current_pose)\r\n                self.last_replan_time = current_time\r\n\r\n        # Follow the current path\r\n        return self.get_next_waypoint()\r\n\r\n    def should_replan(self, current_pose, dynamic_obstacles, current_time):\r\n        """Determine if replanning is needed"""\r\n        # Replan if:\r\n        # 1. No path exists\r\n        if self.current_path is None:\r\n            return True\r\n\r\n        # 2. Time since last replan exceeds interval\r\n        if current_time - self.last_replan_time > self.replan_interval:\r\n            return True\r\n\r\n        # 3. Obstacle collision detected along path\r\n        if self.path_collides_with_obstacles(self.current_path, dynamic_obstacles):\r\n            return True\r\n\r\n        # 4. Robot is too far from planned path\r\n        closest_path_point = self.get_closest_path_point(current_pose)\r\n        distance_to_path = self.distance(current_pose, closest_path_point)\r\n        if distance_to_path > 0.5:  # 0.5m threshold\r\n            return True\r\n\r\n        return False\r\n\r\n    def path_collides_with_obstacles(self, path, obstacles):\r\n        """Check if path collides with any obstacles"""\r\n        for i in range(len(path) - 1):\r\n            for obstacle in obstacles:\r\n                if self.segment_intersects_obstacle(path[i], path[i+1], obstacle):\r\n                    return True\r\n        return False\r\n\r\n    def segment_intersects_obstacle(self, start, end, obstacle):\r\n        """Check if line segment intersects with obstacle"""\r\n        # Simplified collision check - in practice would use more sophisticated methods\r\n        segment_length = self.distance(start, end)\r\n        obstacle_radius = obstacle.get(\'radius\', 0.5)  # Default 0.5m radius\r\n\r\n        # Check distance from obstacle center to line segment\r\n        dist_to_segment = self.distance_point_to_segment(obstacle[\'center\'], start, end)\r\n        return dist_to_segment < obstacle_radius\r\n\r\n    def distance_point_to_segment(self, point, seg_start, seg_end):\r\n        """Calculate distance from point to line segment"""\r\n        # Vector math to calculate distance from point to line segment\r\n        pass\n'})}),"\n",(0,i.jsx)(r.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(r.h3,{id:"path-smoothing",children:"Path Smoothing"}),"\n",(0,i.jsx)(r.p,{children:"Raw planned paths often contain unnecessary waypoints that should be smoothed:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'def smooth_path(path, max_iterations=100, tolerance=0.001):\r\n    """Smooth path by removing unnecessary waypoints"""\r\n    if len(path) < 3:\r\n        return path\r\n\r\n    smoothed_path = path.copy()\r\n\r\n    for _ in range(max_iterations):\r\n        improved = False\r\n\r\n        for i in range(1, len(smoothed_path) - 1):\r\n            # Check if we can connect previous and next points directly\r\n            prev_point = smoothed_path[i-1]\r\n            next_point = smoothed_path[i+1]\r\n\r\n            # Check if direct connection is collision-free\r\n            if is_line_collision_free(prev_point, next_point, obstacles):\r\n                # Remove the middle point\r\n                smoothed_path.pop(i)\r\n                improved = True\r\n                break  # Restart to check from beginning\r\n\r\n        if not improved:\r\n            break\r\n\r\n    return smoothed_path\r\n\r\ndef is_line_collision_free(start, end, obstacles):\r\n    """Check if line segment is collision-free"""\r\n    # Sample points along the line and check for collisions\r\n    num_samples = 10\r\n    for i in range(num_samples + 1):\r\n        t = i / num_samples\r\n        x = start[0] + t * (end[0] - start[0])\r\n        y = start[1] + t * (end[1] - start[1])\r\n\r\n        for obstacle in obstacles:\r\n            if distance((x, y), obstacle.center) < obstacle.radius:\r\n                return False\r\n    return True\n'})}),"\n",(0,i.jsx)(r.h3,{id:"multi-resolution-planning",children:"Multi-Resolution Planning"}),"\n",(0,i.jsx)(r.p,{children:"Use different map resolutions for efficiency:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'class MultiResolutionPlanner:\r\n    def __init__(self, fine_grid, coarse_grid):\r\n        self.fine_grid = fine_grid  # High-resolution local planning\r\n        self.coarse_grid = coarse_grid  # Low-resolution global planning\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using multi-resolution approach"""\r\n        # Plan coarse path first\r\n        coarse_path = self.plan_coarse_path(start, goal)\r\n\r\n        if not coarse_path:\r\n            return None\r\n\r\n        # Refine path using fine resolution\r\n        refined_path = []\r\n        for i in range(len(coarse_path) - 1):\r\n            segment_start = coarse_path[i]\r\n            segment_end = coarse_path[i + 1]\r\n\r\n            # Plan fine path for this segment\r\n            fine_segment = self.plan_fine_path(segment_start, segment_end)\r\n            if fine_segment:\r\n                refined_path.extend(fine_segment[:-1])  # Exclude last point to avoid duplication\r\n            else:\r\n                # If fine planning fails, try to connect directly\r\n                refined_path.append(segment_start)\r\n\r\n        refined_path.append(goal)  # Add final goal\r\n        return refined_path\r\n\r\n    def plan_coarse_path(self, start, goal):\r\n        """Plan path on coarse resolution grid"""\r\n        planner = AStarPlanner(self.coarse_grid)\r\n        return planner.plan_path(start, goal)\r\n\r\n    def plan_fine_path(self, start, goal):\r\n        """Plan path on fine resolution grid"""\r\n        planner = AStarPlanner(self.fine_grid)\r\n        return planner.plan_path(start, goal)\n'})}),"\n",(0,i.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(r.p,{children:"Path planning algorithms form the backbone of autonomous navigation systems, enabling robots to move safely and efficiently through their environment. From classical algorithms like A* to sampling-based methods like RRT, each approach has its strengths for different scenarios."}),"\n",(0,i.jsx)(r.p,{children:"The next section will cover manipulation control systems, which enable robots to interact with objects in their environment."}),"\n",(0,i.jsx)(r.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(r.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function p(n={}){const{wrapper:r}={...(0,a.R)(),...n.components};return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,r,e){e.d(r,{R:()=>o,x:()=>s});var t=e(6540);const i={},a=t.createContext(i);function o(n){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function s(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),t.createElement(a.Provider,{value:r},n.children)}}}]);