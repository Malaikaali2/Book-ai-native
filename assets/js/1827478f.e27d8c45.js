"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[8144],{2059(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"capstone/task-planning","title":"Task Planning and Execution: Autonomous Humanoid Capstone","description":"Overview","source":"@site/docs/capstone/task-planning.md","sourceDirName":"capstone","slug":"/capstone/task-planning","permalink":"/Book-ai-native/docs/capstone/task-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/capstone/task-planning.md","tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"sidebar_position":17},"sidebar":"tutorialSidebar","previous":{"title":"Voice Command Processing Implementation: Autonomous Humanoid Capstone","permalink":"/Book-ai-native/docs/capstone/voice-processing"},"next":{"title":"Navigation and Obstacle Avoidance: Autonomous Humanoid Capstone","permalink":"/Book-ai-native/docs/capstone/navigation"}}');var s=r(4848),a=r(8453);const i={sidebar_position:17},o="Task Planning and Execution: Autonomous Humanoid Capstone",l={},c=[{value:"Overview",id:"overview",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Hierarchical Task Network (HTN) Architecture",id:"hierarchical-task-network-htn-architecture",level:3},{value:"Integration with Other Systems",id:"integration-with-other-systems",level:3},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"1. Task Representation and Decomposition",id:"1-task-representation-and-decomposition",level:3},{value:"Task Structure Definition",id:"task-structure-definition",level:4},{value:"Task Planning Algorithm",id:"task-planning-algorithm",level:4},{value:"2. Action Execution System",id:"2-action-execution-system",level:3},{value:"Task Execution Framework",id:"task-execution-framework",level:4},{value:"3. Monitoring and Replanning System",id:"3-monitoring-and-replanning-system",level:3},{value:"Task Monitoring Framework",id:"task-monitoring-framework",level:4},{value:"Replanning System",id:"replanning-system",level:4},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Set up Task Planning Infrastructure",id:"step-1-set-up-task-planning-infrastructure",level:3},{value:"Step 2: Implement Knowledge Base Integration",id:"step-2-implement-knowledge-base-integration",level:3},{value:"Step 3: Add Advanced Planning Features",id:"step-3-add-advanced-planning-features",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Unit Testing",id:"unit-testing",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:2},{value:"Planning Performance",id:"planning-performance",level:3},{value:"Execution Performance",id:"execution-performance",level:3},{value:"Troubleshooting and Common Issues",id:"troubleshooting-and-common-issues",level:2},{value:"Planning Problems",id:"planning-problems",level:3},{value:"Execution Problems",id:"execution-problems",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Design Principles",id:"design-principles",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Next Steps and Integration",id:"next-steps-and-integration",level:2},{value:"Integration with Other Capstone Components",id:"integration-with-other-capstone-components",level:3},{value:"Advanced Features",id:"advanced-features",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"task-planning-and-execution-autonomous-humanoid-capstone",children:"Task Planning and Execution: Autonomous Humanoid Capstone"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Task planning and execution represents the cognitive layer of the autonomous humanoid system, bridging high-level goals from voice commands with low-level robot actions. This component decomposes complex tasks into executable sequences, manages dependencies between actions, handles dynamic replanning when obstacles arise, and ensures safe and efficient task completion. The system must handle both simple single-step tasks and complex multi-step operations while maintaining awareness of the robot's capabilities and environmental constraints."}),"\n",(0,s.jsx)(n.p,{children:"The task planning system integrates seamlessly with voice processing to interpret user commands, with navigation for mobility tasks, with manipulation for object interaction, and with perception for environmental awareness. This implementation guide provides detailed instructions for building a sophisticated task planning and execution framework that can handle the complexity of real-world scenarios."}),"\n",(0,s.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"hierarchical-task-network-htn-architecture",children:"Hierarchical Task Network (HTN) Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The task planning system employs a Hierarchical Task Network (HTN) approach that decomposes high-level goals into sequences of primitive actions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"High-Level Goal \u2192 Task Decomposition \u2192 Action Sequencing \u2192 Execution Monitoring \u2192 Feedback Integration\n"})}),"\n",(0,s.jsx)(n.p,{children:"The architecture consists of:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Goal Parser"}),": Interprets goals from voice processing system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Decomposer"}),": Breaks complex tasks into subtasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Sequencer"}),": Orders actions based on dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Executor"}),": Coordinates with other systems to execute actions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor"}),": Tracks execution progress and detects failures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Replanner"}),": Adjusts plans when failures or new information occur"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"integration-with-other-systems",children:"Integration with Other Systems"}),"\n",(0,s.jsx)(n.p,{children:"The task planning system interfaces with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Voice Processing"}),": Receives high-level goals and commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Navigation System"}),": Plans and executes mobility tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manipulation System"}),": Coordinates object interaction tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Perception System"}),": Requests environmental information"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Knowledge Base"}),": Accesses object properties and location information"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"1-task-representation-and-decomposition",children:"1. Task Representation and Decomposition"}),"\n",(0,s.jsx)(n.h4,{id:"task-structure-definition",children:"Task Structure Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from enum import Enum\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Dict, Any, Optional\r\nimport rospy\r\n\r\nclass TaskType(Enum):\r\n    NAVIGATION = "navigation"\r\n    MANIPULATION = "manipulation"\r\n    PERCEPTION = "perception"\r\n    COMPOSITE = "composite"\r\n    QUERY = "query"\r\n\r\nclass TaskStatus(Enum):\r\n    PENDING = "pending"\r\n    RUNNING = "running"\r\n    SUCCESS = "success"\r\n    FAILED = "failed"\r\n    CANCELLED = "cancelled"\r\n\r\n@dataclass\r\nclass Task:\r\n    """Represents a single task in the planning system"""\r\n    id: str\r\n    type: TaskType\r\n    goal: Dict[str, Any]\r\n    dependencies: List[str]  # Task IDs this task depends on\r\n    priority: int = 0\r\n    status: TaskStatus = TaskStatus.PENDING\r\n    created_time: float = 0.0\r\n    start_time: Optional[float] = None\r\n    end_time: Optional[float] = None\r\n    execution_result: Optional[Dict[str, Any]] = None\r\n\r\nclass TaskDecomposer:\r\n    """Decomposes high-level goals into primitive tasks"""\r\n\r\n    def __init__(self):\r\n        self.task_library = self._initialize_task_library()\r\n\r\n    def _initialize_task_library(self) -> Dict[str, List[Task]]:\r\n        """Initialize library of known task decompositions"""\r\n        return {\r\n            \'go_to_location\': [\r\n                Task(\r\n                    id=\'navigation_task\',\r\n                    type=TaskType.NAVIGATION,\r\n                    goal={\'target_location\': None},\r\n                    dependencies=[]\r\n                )\r\n            ],\r\n            \'pick_up_object\': [\r\n                Task(\r\n                    id=\'approach_object\',\r\n                    type=TaskType.NAVIGATION,\r\n                    goal={\'target_location\': None, \'approach_distance\': 0.5},\r\n                    dependencies=[]\r\n                ),\r\n                Task(\r\n                    id=\'detect_object\',\r\n                    type=TaskType.PERCEPTION,\r\n                    goal={\'object_type\': None, \'search_area\': None},\r\n                    dependencies=[\'approach_object\']\r\n                ),\r\n                Task(\r\n                    id=\'grasp_object\',\r\n                    type=TaskType.MANIPULATION,\r\n                    goal={\'object_id\': None, \'grasp_type\': \'pinch\'},\r\n                    dependencies=[\'detect_object\']\r\n                )\r\n            ],\r\n            \'place_object\': [\r\n                Task(\r\n                    id=\'navigate_to_place\',\r\n                    type=TaskType.NAVIGATION,\r\n                    goal={\'target_location\': None},\r\n                    dependencies=[]\r\n                ),\r\n                Task(\r\n                    id=\'place_object_action\',\r\n                    type=TaskType.MANIPULATION,\r\n                    goal={\'placement_location\': None, \'object_to_place\': None},\r\n                    dependencies=[\'navigate_to_place\']\r\n                )\r\n            ]\r\n        }\r\n\r\n    def decompose_goal(self, goal: Dict[str, Any]) -> List[Task]:\r\n        """Decompose a high-level goal into primitive tasks"""\r\n        goal_type = goal.get(\'type\')\r\n        goal_params = goal.get(\'parameters\', {})\r\n\r\n        if goal_type in self.task_library:\r\n            # Create task copies with specific parameters\r\n            tasks = []\r\n            for template_task in self.task_library[goal_type]:\r\n                task = Task(\r\n                    id=f"{template_task.id}_{rospy.get_time()}",\r\n                    type=template_task.type,\r\n                    goal=self._substitute_parameters(template_task.goal, goal_params),\r\n                    dependencies=template_task.dependencies,\r\n                    priority=goal.get(\'priority\', 0)\r\n                )\r\n                tasks.append(task)\r\n\r\n            return tasks\r\n        else:\r\n            # Default decomposition for unknown goals\r\n            return self._default_decomposition(goal)\r\n\r\n    def _substitute_parameters(self, template_goal: Dict, params: Dict) -> Dict:\r\n        """Substitute template parameters with actual values"""\r\n        result = template_goal.copy()\r\n        for key, value in params.items():\r\n            if key in result:\r\n                result[key] = value\r\n        return result\r\n\r\n    def _default_decomposition(self, goal: Dict[str, Any]) -> List[Task]:\r\n        """Default decomposition for unknown goal types"""\r\n        # For now, return a single composite task\r\n        return [Task(\r\n            id=f"composite_{rospy.get_time()}",\r\n            type=TaskType.COMPOSITE,\r\n            goal=goal,\r\n            dependencies=[],\r\n            priority=goal.get(\'priority\', 0)\r\n        )]\n'})}),"\n",(0,s.jsx)(n.h4,{id:"task-planning-algorithm",children:"Task Planning Algorithm"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from collections import defaultdict, deque\r\nimport heapq\r\n\r\nclass TaskPlanner:\r\n    """Manages the planning and scheduling of tasks"""\r\n\r\n    def __init__(self):\r\n        self.tasks = {}  # task_id -> Task\r\n        self.dependency_graph = defaultdict(list)  # task_id -> [dependent_task_ids]\r\n        self.ready_queue = []  # Priority queue of ready tasks\r\n        self.executor = TaskExecutor()\r\n\r\n    def add_tasks(self, tasks: List[Task]):\r\n        """Add tasks to the planning system"""\r\n        for task in tasks:\r\n            self.tasks[task.id] = task\r\n\r\n            # Build dependency graph\r\n            for dep_id in task.dependencies:\r\n                self.dependency_graph[dep_id].append(task.id)\r\n\r\n        # Add tasks with no dependencies to ready queue\r\n        self._update_ready_queue()\r\n\r\n    def _update_ready_queue(self):\r\n        """Update the ready queue based on task dependencies and status"""\r\n        for task_id, task in self.tasks.items():\r\n            if task.status == TaskStatus.PENDING and self._are_dependencies_met(task_id):\r\n                heapq.heappush(self.ready_queue, (-task.priority, task_id, task))\r\n\r\n    def _are_dependencies_met(self, task_id: str) -> bool:\r\n        """Check if all dependencies for a task are satisfied"""\r\n        task = self.tasks[task_id]\r\n        for dep_id in task.dependencies:\r\n            if dep_id not in self.tasks:\r\n                return False\r\n            if self.tasks[dep_id].status != TaskStatus.SUCCESS:\r\n                return False\r\n        return True\r\n\r\n    def get_next_task(self) -> Optional[Task]:\r\n        """Get the next task to execute based on priority"""\r\n        if self.ready_queue:\r\n            priority, task_id, task = heapq.heappop(self.ready_queue)\r\n            return task\r\n        return None\r\n\r\n    def update_task_status(self, task_id: str, status: TaskStatus, result: Optional[Dict] = None):\r\n        """Update the status of a task and propagate changes"""\r\n        if task_id in self.tasks:\r\n            task = self.tasks[task_id]\r\n            task.status = status\r\n            task.execution_result = result\r\n\r\n            # Update ready queue with newly available tasks\r\n            self._update_ready_queue()\r\n\r\n            # Check if dependent tasks can now be executed\r\n            for dependent_id in self.dependency_graph[task_id]:\r\n                if self._are_dependencies_met(dependent_id):\r\n                    dependent_task = self.tasks[dependent_id]\r\n                    heapq.heappush(self.ready_queue, (-dependent_task.priority, dependent_id, dependent_task))\r\n\r\n    def cancel_task(self, task_id: str):\r\n        """Cancel a pending task"""\r\n        if task_id in self.tasks:\r\n            task = self.tasks[task_id]\r\n            if task.status == TaskStatus.PENDING:\r\n                task.status = TaskStatus.CANCELLED\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-action-execution-system",children:"2. Action Execution System"}),"\n",(0,s.jsx)(n.h4,{id:"task-execution-framework",children:"Task Execution Framework"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import threading\r\nimport time\r\nfrom typing import Callable\r\n\r\nclass TaskExecutor:\r\n    \"\"\"Executes tasks by interfacing with other robot systems\"\"\"\r\n\r\n    def __init__(self):\r\n        # Publishers for different system interfaces\r\n        self.navigation_pub = rospy.Publisher('/move_base_simple/goal', PoseStamped, queue_size=10)\r\n        self.manipulation_pub = rospy.Publisher('/manipulation_commands', String, queue_size=10)\r\n        self.perception_pub = rospy.Publisher('/perception_commands', String, queue_size=10)\r\n\r\n        # Subscribers for feedback\r\n        self.navigation_sub = rospy.Subscriber('/move_base/status', String, self._navigation_callback)\r\n        self.manipulation_sub = rospy.Subscriber('/manipulation/status', String, self._manipulation_callback)\r\n\r\n        self.active_tasks = {}  # task_id -> execution thread\r\n        self.execution_lock = threading.Lock()\r\n\r\n    def execute_task(self, task: Task, callback: Callable[[str, TaskStatus, Optional[Dict]], None]):\r\n        \"\"\"Execute a single task asynchronously\"\"\"\r\n        with self.execution_lock:\r\n            thread = threading.Thread(\r\n                target=self._execute_task_thread,\r\n                args=(task, callback)\r\n            )\r\n            thread.daemon = True\r\n            thread.start()\r\n            self.active_tasks[task.id] = thread\r\n\r\n        return True\r\n\r\n    def _execute_task_thread(self, task: Task, callback: Callable):\r\n        \"\"\"Execute task in separate thread\"\"\"\r\n        try:\r\n            task.start_time = rospy.get_time()\r\n\r\n            # Execute based on task type\r\n            if task.type == TaskType.NAVIGATION:\r\n                result = self._execute_navigation_task(task)\r\n            elif task.type == TaskType.MANIPULATION:\r\n                result = self._execute_manipulation_task(task)\r\n            elif task.type == TaskType.PERCEPTION:\r\n                result = self._execute_perception_task(task)\r\n            elif task.type == TaskType.COMPOSITE:\r\n                result = self._execute_composite_task(task)\r\n            else:\r\n                result = {'success': False, 'error': f'Unknown task type: {task.type}'}\r\n\r\n            # Determine status based on result\r\n            status = TaskStatus.SUCCESS if result.get('success', False) else TaskStatus.FAILED\r\n\r\n            # Update task completion time\r\n            task.end_time = rospy.get_time()\r\n            task.execution_result = result\r\n\r\n            # Call completion callback\r\n            callback(task.id, status, result)\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error executing task {task.id}: {e}\")\r\n            callback(task.id, TaskStatus.FAILED, {'success': False, 'error': str(e)})\r\n        finally:\r\n            with self.execution_lock:\r\n                if task.id in self.active_tasks:\r\n                    del self.active_tasks[task.id]\r\n\r\n    def _execute_navigation_task(self, task: Task) -> Dict[str, Any]:\r\n        \"\"\"Execute navigation task\"\"\"\r\n        try:\r\n            target_location = task.goal.get('target_location')\r\n            if not target_location:\r\n                return {'success': False, 'error': 'No target location specified'}\r\n\r\n            # Convert location name to coordinates\r\n            coordinates = self._get_coordinates_for_location(target_location)\r\n            if not coordinates:\r\n                return {'success': False, 'error': f'Unknown location: {target_location}'}\r\n\r\n            # Create and publish navigation goal\r\n            goal = PoseStamped()\r\n            goal.header.frame_id = \"map\"\r\n            goal.header.stamp = rospy.Time.now()\r\n            goal.pose.position.x = coordinates['x']\r\n            goal.pose.position.y = coordinates['y']\r\n            goal.pose.orientation.z = coordinates.get('theta', 0.0)\r\n\r\n            self.navigation_pub.publish(goal)\r\n\r\n            # Wait for navigation to complete (with timeout)\r\n            start_time = rospy.get_time()\r\n            timeout = task.goal.get('timeout', 60.0)  # Default 60 second timeout\r\n\r\n            while not self._is_navigation_complete() and (rospy.get_time() - start_time) < timeout:\r\n                rospy.sleep(0.1)\r\n\r\n            if (rospy.get_time() - start_time) >= timeout:\r\n                return {'success': False, 'error': 'Navigation timeout'}\r\n\r\n            return {'success': True, 'location': target_location}\r\n\r\n        except Exception as e:\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    def _execute_manipulation_task(self, task: Task) -> Dict[str, Any]:\r\n        \"\"\"Execute manipulation task\"\"\"\r\n        try:\r\n            # Create manipulation command based on goal\r\n            command = {\r\n                'action': task.goal.get('action', 'grasp'),\r\n                'object': task.goal.get('object_id'),\r\n                'location': task.goal.get('target_location'),\r\n                'grasp_type': task.goal.get('grasp_type', 'default')\r\n            }\r\n\r\n            # Publish manipulation command\r\n            self.manipulation_pub.publish(str(command))\r\n\r\n            # Wait for manipulation to complete\r\n            start_time = rospy.get_time()\r\n            timeout = task.goal.get('timeout', 30.0)\r\n\r\n            while not self._is_manipulation_complete() and (rospy.get_time() - start_time) < timeout:\r\n                rospy.sleep(0.1)\r\n\r\n            if (rospy.get_time() - start_time) >= timeout:\r\n                return {'success': False, 'error': 'Manipulation timeout'}\r\n\r\n            return {'success': True, 'action': command['action']}\r\n\r\n        except Exception as e:\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    def _execute_perception_task(self, task: Task) -> Dict[str, Any]:\r\n        \"\"\"Execute perception task\"\"\"\r\n        try:\r\n            # Create perception command\r\n            command = {\r\n                'task': task.goal.get('task', 'detect'),\r\n                'object_type': task.goal.get('object_type'),\r\n                'search_area': task.goal.get('search_area')\r\n            }\r\n\r\n            # Publish perception command\r\n            self.perception_pub.publish(str(command))\r\n\r\n            # Wait for perception results\r\n            start_time = rospy.get_time()\r\n            timeout = task.goal.get('timeout', 10.0)\r\n\r\n            results = self._wait_for_perception_results(timeout)\r\n\r\n            if not results:\r\n                return {'success': False, 'error': 'Perception timeout or no results'}\r\n\r\n            return {'success': True, 'results': results}\r\n\r\n        except Exception as e:\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    def _execute_composite_task(self, task: Task) -> Dict[str, Any]:\r\n        \"\"\"Execute composite task by decomposing and executing subtasks\"\"\"\r\n        try:\r\n            # For composite tasks, we might need to decompose further\r\n            # This is a simplified version - in practice, this might trigger\r\n            # a recursive decomposition\r\n            subtasks = self._decompose_composite_task(task)\r\n\r\n            for subtask in subtasks:\r\n                result = self._execute_single_task_sync(subtask)\r\n                if not result.get('success', False):\r\n                    return result\r\n\r\n            return {'success': True, 'subtasks_completed': len(subtasks)}\r\n\r\n        except Exception as e:\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    def _get_coordinates_for_location(self, location_name: str) -> Optional[Dict]:\r\n        \"\"\"Convert location name to coordinates\"\"\"\r\n        # This would typically come from a knowledge base or map\r\n        location_map = {\r\n            'kitchen': {'x': 2.0, 'y': 1.0, 'theta': 0.0},\r\n            'living_room': {'x': -1.0, 'y': 2.0, 'theta': 1.57},\r\n            'bedroom': {'x': 3.0, 'y': -2.0, 'theta': 3.14},\r\n            'office': {'x': -2.0, 'y': -1.0, 'theta': -1.57}\r\n        }\r\n\r\n        return location_map.get(location_name.lower().replace(' ', '_'))\r\n\r\n    def _is_navigation_complete(self) -> bool:\r\n        \"\"\"Check if navigation is complete\"\"\"\r\n        # This would typically check navigation status feedback\r\n        # For now, we'll simulate completion\r\n        return True  # Simplified for example\r\n\r\n    def _is_manipulation_complete(self) -> bool:\r\n        \"\"\"Check if manipulation is complete\"\"\"\r\n        # This would typically check manipulation status feedback\r\n        return True  # Simplified for example\r\n\r\n    def _wait_for_perception_results(self, timeout: float) -> Optional[Dict]:\r\n        \"\"\"Wait for perception results\"\"\"\r\n        # This would typically wait for perception system feedback\r\n        return {'objects': [], 'locations': []}  # Simplified for example\r\n\r\n    def _decompose_composite_task(self, task: Task) -> List[Task]:\r\n        \"\"\"Decompose composite task into subtasks\"\"\"\r\n        # This would use the TaskDecomposer\r\n        decomposer = TaskDecomposer()\r\n        return decomposer.decompose_goal(task.goal)\r\n\r\n    def _execute_single_task_sync(self, task: Task) -> Dict[str, Any]:\r\n        \"\"\"Execute a single task synchronously (for internal use)\"\"\"\r\n        # This is a simplified synchronous execution for subtasks\r\n        if task.type == TaskType.NAVIGATION:\r\n            return self._execute_navigation_task(task)\r\n        elif task.type == TaskType.MANIPULATION:\r\n            return self._execute_manipulation_task(task)\r\n        elif task.type == TaskType.PERCEPTION:\r\n            return self._execute_perception_task(task)\r\n        else:\r\n            return {'success': False, 'error': f'Unsupported task type: {task.type}'}\r\n\r\n    def _navigation_callback(self, msg):\r\n        \"\"\"Handle navigation status updates\"\"\"\r\n        pass  # Implementation would update navigation state\r\n\r\n    def _manipulation_callback(self, msg):\r\n        \"\"\"Handle manipulation status updates\"\"\"\r\n        pass  # Implementation would update manipulation state\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-monitoring-and-replanning-system",children:"3. Monitoring and Replanning System"}),"\n",(0,s.jsx)(n.h4,{id:"task-monitoring-framework",children:"Task Monitoring Framework"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import time\r\nfrom datetime import datetime\r\n\r\nclass TaskMonitor:\r\n    \"\"\"Monitors task execution and detects failures or anomalies\"\"\"\r\n\r\n    def __init__(self, planner: TaskPlanner):\r\n        self.planner = planner\r\n        self.task_start_times = {}\r\n        self.task_timeouts = {}\r\n        self.failure_thresholds = {\r\n            'execution_time': 120.0,  # 2 minutes max execution time\r\n            'resource_usage': 0.8,    # 80% max resource usage\r\n        }\r\n\r\n    def start_monitoring_task(self, task: Task):\r\n        \"\"\"Start monitoring a task\"\"\"\r\n        self.task_start_times[task.id] = rospy.get_time()\r\n\r\n        # Set timeout based on task type and complexity\r\n        if task.type == TaskType.NAVIGATION:\r\n            self.task_timeouts[task.id] = task.goal.get('timeout', 60.0)\r\n        elif task.type == TaskType.MANIPULATION:\r\n            self.task_timeouts[task.id] = task.goal.get('timeout', 30.0)\r\n        else:\r\n            self.task_timeouts[task.id] = task.goal.get('timeout', 20.0)\r\n\r\n    def check_task_health(self, task_id: str) -> Dict[str, Any]:\r\n        \"\"\"Check the health of a running task\"\"\"\r\n        if task_id not in self.task_start_times:\r\n            return {'healthy': True, 'status': 'not_monitored'}\r\n\r\n        current_time = rospy.get_time()\r\n        start_time = self.task_start_times[task_id]\r\n        elapsed_time = current_time - start_time\r\n        timeout = self.task_timeouts[task_id]\r\n\r\n        health_report = {\r\n            'task_id': task_id,\r\n            'elapsed_time': elapsed_time,\r\n            'timeout': timeout,\r\n            'time_remaining': timeout - elapsed_time,\r\n            'healthy': True,\r\n            'issues': []\r\n        }\r\n\r\n        # Check for timeout\r\n        if elapsed_time > timeout:\r\n            health_report['healthy'] = False\r\n            health_report['issues'].append(f'Task exceeded timeout: {elapsed_time}s > {timeout}s')\r\n\r\n        # Check for resource constraints (simulated)\r\n        # In real implementation, this would check CPU, memory, etc.\r\n        if self._check_resource_usage() > self.failure_thresholds['resource_usage']:\r\n            health_report['healthy'] = False\r\n            health_report['issues'].append('High resource usage detected')\r\n\r\n        return health_report\r\n\r\n    def _check_resource_usage(self) -> float:\r\n        \"\"\"Check current resource usage (simulated)\"\"\"\r\n        # This would interface with system monitoring tools\r\n        import psutil\r\n        return psutil.cpu_percent() / 100.0\r\n\r\n    def detect_failures(self) -> List[str]:\r\n        \"\"\"Detect failed tasks and return their IDs\"\"\"\r\n        failed_tasks = []\r\n\r\n        for task_id, task in self.planner.tasks.items():\r\n            if task.status == TaskStatus.RUNNING:\r\n                health = self.check_task_health(task_id)\r\n                if not health['healthy']:\r\n                    failed_tasks.append(task_id)\r\n\r\n        return failed_tasks\n"})}),"\n",(0,s.jsx)(n.h4,{id:"replanning-system",children:"Replanning System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Replanner:\r\n    \"\"\"Handles dynamic replanning when failures occur or conditions change\"\"\"\r\n\r\n    def __init__(self, planner: TaskPlanner, monitor: TaskMonitor):\r\n        self.planner = planner\r\n        self.monitor = monitor\r\n        self.failure_recovery_strategies = self._initialize_recovery_strategies()\r\n\r\n    def _initialize_recovery_strategies(self) -> Dict[str, Callable]:\r\n        \"\"\"Initialize failure recovery strategies\"\"\"\r\n        return {\r\n            'navigation_timeout': self._handle_navigation_timeout,\r\n            'manipulation_failure': self._handle_manipulation_failure,\r\n            'object_not_found': self._handle_object_not_found,\r\n            'obstacle_detected': self._handle_obstacle_detected,\r\n        }\r\n\r\n    def handle_task_failure(self, task_id: str, failure_reason: str) -> bool:\r\n        \"\"\"Handle a failed task and attempt recovery\"\"\"\r\n        rospy.logwarn(f\"Task {task_id} failed: {failure_reason}\")\r\n\r\n        # Determine appropriate recovery strategy\r\n        strategy_key = self._classify_failure(failure_reason)\r\n\r\n        if strategy_key in self.failure_recovery_strategies:\r\n            recovery_success = self.failure_recovery_strategies[strategy_key](task_id)\r\n\r\n            if recovery_success:\r\n                rospy.loginfo(f\"Recovery successful for task {task_id}\")\r\n                return True\r\n            else:\r\n                rospy.logerr(f\"Recovery failed for task {task_id}\")\r\n                return False\r\n        else:\r\n            rospy.logerr(f\"No recovery strategy for failure: {failure_reason}\")\r\n            return False\r\n\r\n    def _classify_failure(self, failure_reason: str) -> str:\r\n        \"\"\"Classify failure reason to appropriate recovery strategy\"\"\"\r\n        failure_lower = failure_reason.lower()\r\n\r\n        if 'timeout' in failure_lower and 'navigation' in failure_lower:\r\n            return 'navigation_timeout'\r\n        elif 'timeout' in failure_lower and 'manipulation' in failure_lower:\r\n            return 'manipulation_failure'\r\n        elif 'not found' in failure_lower or 'not detected' in failure_lower:\r\n            return 'object_not_found'\r\n        elif 'obstacle' in failure_lower or 'collision' in failure_lower:\r\n            return 'obstacle_detected'\r\n        else:\r\n            return 'general_failure'\r\n\r\n    def _handle_navigation_timeout(self, task_id: str) -> bool:\r\n        \"\"\"Handle navigation timeout by trying alternative routes\"\"\"\r\n        try:\r\n            # Get the failed navigation task\r\n            task = self.planner.tasks[task_id]\r\n            target_location = task.goal.get('target_location')\r\n\r\n            if not target_location:\r\n                return False\r\n\r\n            # Try alternative route (simplified approach)\r\n            alternative_route = self._find_alternative_route(target_location)\r\n\r\n            if alternative_route:\r\n                # Create new navigation task with alternative route\r\n                new_task = Task(\r\n                    id=f\"{task_id}_retry_{rospy.get_time()}\",\r\n                    type=TaskType.NAVIGATION,\r\n                    goal={**task.goal, 'alternative_route': alternative_route},\r\n                    dependencies=task.dependencies,\r\n                    priority=task.priority + 1  # Higher priority for retry\r\n                )\r\n\r\n                # Add new task to planner\r\n                self.planner.add_tasks([new_task])\r\n\r\n                # Mark original task as failed\r\n                self.planner.update_task_status(task_id, TaskStatus.FAILED,\r\n                                              {'recovery': 'alternative_route_attempted'})\r\n\r\n                return True\r\n            else:\r\n                return False\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error handling navigation timeout: {e}\")\r\n            return False\r\n\r\n    def _handle_manipulation_failure(self, task_id: str) -> bool:\r\n        \"\"\"Handle manipulation failure by trying alternative grasps or approaches\"\"\"\r\n        try:\r\n            task = self.planner.tasks[task_id]\r\n            object_id = task.goal.get('object_id')\r\n\r\n            if not object_id:\r\n                return False\r\n\r\n            # Try alternative grasp strategy\r\n            alternative_grasps = self._get_alternative_grasps(object_id)\r\n\r\n            if alternative_grasps:\r\n                # Create new manipulation task with alternative grasp\r\n                new_task = Task(\r\n                    id=f\"{task_id}_retry_{rospy.get_time()}\",\r\n                    type=TaskType.MANIPULATION,\r\n                    goal={**task.goal, 'grasp_type': alternative_grasps[0]},\r\n                    dependencies=task.dependencies,\r\n                    priority=task.priority + 1\r\n                )\r\n\r\n                self.planner.add_tasks([new_task])\r\n                self.planner.update_task_status(task_id, TaskStatus.FAILED,\r\n                                              {'recovery': 'alternative_grasp_attempted'})\r\n\r\n                return True\r\n            else:\r\n                return False\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error handling manipulation failure: {e}\")\r\n            return False\r\n\r\n    def _handle_object_not_found(self, task_id: str) -> bool:\r\n        \"\"\"Handle object not found by expanding search area or querying knowledge base\"\"\"\r\n        try:\r\n            task = self.planner.tasks[task_id]\r\n            object_type = task.goal.get('object_type') or task.goal.get('object_id')\r\n\r\n            if not object_type:\r\n                return False\r\n\r\n            # Query knowledge base for possible locations\r\n            possible_locations = self._query_knowledge_base(object_type)\r\n\r\n            if possible_locations:\r\n                # Create perception tasks to search in alternative locations\r\n                search_tasks = []\r\n                for location in possible_locations[:3]:  # Limit to first 3 locations\r\n                    search_task = Task(\r\n                        id=f\"search_{object_type}_{location}_{rospy.get_time()}\",\r\n                        type=TaskType.PERCEPTION,\r\n                        goal={\r\n                            'task': 'detect',\r\n                            'object_type': object_type,\r\n                            'search_area': location\r\n                        },\r\n                        dependencies=task.dependencies\r\n                    )\r\n                    search_tasks.append(search_task)\r\n\r\n                self.planner.add_tasks(search_tasks)\r\n                return True\r\n            else:\r\n                return False\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error handling object not found: {e}\")\r\n            return False\r\n\r\n    def _handle_obstacle_detected(self, task_id: str) -> bool:\r\n        \"\"\"Handle obstacle detection by replanning around obstacles\"\"\"\r\n        try:\r\n            # This would interface with navigation system to replan\r\n            # For now, we'll just mark the task as failed and let higher level\r\n            # decide on next steps\r\n            self.planner.update_task_status(task_id, TaskStatus.FAILED,\r\n                                          {'recovery': 'obstacle_detected_needs_replanning'})\r\n            return False  # Return False to indicate task should be abandoned\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f\"Error handling obstacle detection: {e}\")\r\n            return False\r\n\r\n    def _find_alternative_route(self, target_location: str) -> Optional[Dict]:\r\n        \"\"\"Find alternative route to target location\"\"\"\r\n        # This would interface with path planning system\r\n        # For now, return a simple alternative\r\n        return {'type': 'alternative', 'data': 'via_corridor'}\r\n\r\n    def _get_alternative_grasps(self, object_id: str) -> List[str]:\r\n        \"\"\"Get alternative grasp strategies for an object\"\"\"\r\n        # This would query object properties and grasp databases\r\n        return ['side_grasp', 'top_grasp', 'pinch_grasp']\r\n\r\n    def _query_knowledge_base(self, object_type: str) -> List[str]:\r\n        \"\"\"Query knowledge base for possible object locations\"\"\"\r\n        # This would interface with semantic knowledge base\r\n        knowledge_base = {\r\n            'cup': ['kitchen_counter', 'dining_table', 'office_desk'],\r\n            'book': ['bookshelf', 'office_desk', 'bedside_table'],\r\n            'keys': ['entrance_table', 'kitchen_counter', 'bedroom_dresser']\r\n        }\r\n\r\n        return knowledge_base.get(object_type.lower(), [])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-set-up-task-planning-infrastructure",children:"Step 1: Set up Task Planning Infrastructure"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create the main task planning node:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport rospy\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import PoseStamped\r\n\r\nclass TaskPlanningNode:\r\n    def __init__(self):\r\n        rospy.init_node(\'task_planning_node\')\r\n\r\n        # Initialize components\r\n        self.decomposer = TaskDecomposer()\r\n        self.planner = TaskPlanner()\r\n        self.monitor = TaskMonitor(self.planner)\r\n        self.replanner = Replanner(self.planner, self.monitor)\r\n\r\n        # Publishers and subscribers\r\n        self.goal_subscriber = rospy.Subscriber(\'/high_level_goals\', String, self.goal_callback)\r\n        self.status_publisher = rospy.Publisher(\'/task_status\', String, queue_size=10)\r\n\r\n        # Task completion callback\r\n        self.task_callback = self._task_completion_callback\r\n\r\n        rospy.loginfo("Task planning system initialized")\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle incoming high-level goals"""\r\n        try:\r\n            # Parse goal from message (assuming JSON format)\r\n            import json\r\n            goal = json.loads(msg.data)\r\n\r\n            # Decompose goal into tasks\r\n            tasks = self.decomposer.decompose_goal(goal)\r\n\r\n            # Add tasks to planner\r\n            self.planner.add_tasks(tasks)\r\n\r\n            # Start executing tasks\r\n            self._execute_ready_tasks()\r\n\r\n            rospy.loginfo(f"Added {len(tasks)} tasks for goal: {goal}")\r\n\r\n        except Exception as e:\r\n            rospy.logerr(f"Error processing goal: {e}")\r\n\r\n    def _execute_ready_tasks(self):\r\n        """Execute all ready tasks"""\r\n        while True:\r\n            task = self.planner.get_next_task()\r\n            if task:\r\n                # Monitor the task\r\n                self.monitor.start_monitoring_task(task)\r\n\r\n                # Execute the task\r\n                success = self.planner.executor.execute_task(task, self.task_callback)\r\n\r\n                if not success:\r\n                    rospy.logerr(f"Failed to start execution of task {task.id}")\r\n                    self.planner.update_task_status(task.id, TaskStatus.FAILED)\r\n            else:\r\n                break  # No more ready tasks\r\n\r\n    def _task_completion_callback(self, task_id: str, status: TaskStatus, result: Optional[Dict]):\r\n        """Handle task completion"""\r\n        rospy.loginfo(f"Task {task_id} completed with status: {status}")\r\n\r\n        # Update task status in planner\r\n        self.planner.update_task_status(task_id, status, result)\r\n\r\n        # Check for failures and handle them\r\n        if status == TaskStatus.FAILED:\r\n            failure_reason = result.get(\'error\', \'Unknown error\') if result else \'Unknown error\'\r\n            recovery_success = self.replanner.handle_task_failure(task_id, failure_reason)\r\n\r\n            if not recovery_success:\r\n                rospy.logerr(f"Could not recover from task failure: {task_id}")\r\n\r\n        # Execute any newly ready tasks\r\n        self._execute_ready_tasks()\r\n\r\n        # Publish status update\r\n        status_msg = String()\r\n        status_msg.data = f"Task {task_id}: {status.value}"\r\n        self.status_publisher.publish(status_msg)\r\n\r\n    def run(self):\r\n        """Main execution loop"""\r\n        rate = rospy.Rate(10)  # 10 Hz\r\n\r\n        while not rospy.is_shutdown():\r\n            # Check for failed tasks\r\n            failed_tasks = self.monitor.detect_failures()\r\n            for task_id in failed_tasks:\r\n                self.replanner.handle_task_failure(task_id, "timeout_detected")\r\n\r\n            rate.sleep()\r\n\r\nif __name__ == \'__main__\':\r\n    node = TaskPlanningNode()\r\n    try:\r\n        node.run()\r\n    except rospy.ROSInterruptException:\r\n        pass\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-implement-knowledge-base-integration",children:"Step 2: Implement Knowledge Base Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class KnowledgeBaseInterface:\r\n    \"\"\"Interface to semantic knowledge base\"\"\"\r\n\r\n    def __init__(self):\r\n        self.object_properties = self._load_object_properties()\r\n        self.location_semantics = self._load_location_semantics()\r\n        self.task_preferences = self._load_task_preferences()\r\n\r\n    def _load_object_properties(self) -> Dict:\r\n        \"\"\"Load object properties from knowledge base\"\"\"\r\n        return {\r\n            'cup': {\r\n                'grasp_points': ['handle', 'body'],\r\n                'typical_locations': ['kitchen', 'dining_room', 'office'],\r\n                'manipulation_constraints': {'max_weight': 0.5, 'fragile': True}\r\n            },\r\n            'book': {\r\n                'grasp_points': ['spine', 'cover'],\r\n                'typical_locations': ['bookshelf', 'desk', 'bedside_table'],\r\n                'manipulation_constraints': {'max_weight': 1.0, 'fragile': False}\r\n            }\r\n        }\r\n\r\n    def _load_location_semantics(self) -> Dict:\r\n        \"\"\"Load location semantics and relationships\"\"\"\r\n        return {\r\n            'kitchen': {\r\n                'contains': ['cup', 'plate', 'utensil'],\r\n                'accessibility': 'high',\r\n                'navigation_difficulty': 'low'\r\n            },\r\n            'bedroom': {\r\n                'contains': ['book', 'clothes', 'personal_items'],\r\n                'accessibility': 'medium',\r\n                'navigation_difficulty': 'medium'\r\n            }\r\n        }\r\n\r\n    def _load_task_preferences(self) -> Dict:\r\n        \"\"\"Load task execution preferences\"\"\"\r\n        return {\r\n            'manipulation': {\r\n                'preferred_grasp': 'pinch',\r\n                'safety_margin': 0.1\r\n            },\r\n            'navigation': {\r\n                'preferred_paths': ['main_corridors'],\r\n                'avoidance_zones': ['construction_areas']\r\n            }\r\n        }\r\n\r\n    def get_object_property(self, object_type: str, property_name: str) -> Any:\r\n        \"\"\"Get a specific property of an object\"\"\"\r\n        obj_props = self.object_properties.get(object_type, {})\r\n        return obj_props.get(property_name)\r\n\r\n    def get_typical_locations(self, object_type: str) -> List[str]:\r\n        \"\"\"Get typical locations where an object might be found\"\"\"\r\n        return self.get_object_property(object_type, 'typical_locations') or []\r\n\r\n    def get_manipulation_constraints(self, object_type: str) -> Dict:\r\n        \"\"\"Get manipulation constraints for an object\"\"\"\r\n        return self.get_object_property(object_type, 'manipulation_constraints') or {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-add-advanced-planning-features",children:"Step 3: Add Advanced Planning Features"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class AdvancedPlanner:\r\n    """Advanced planning features including temporal and resource constraints"""\r\n\r\n    def __init__(self, base_planner: TaskPlanner):\r\n        self.base_planner = base_planner\r\n        self.resource_manager = ResourceManager()\r\n        self.temporal_constraints = {}\r\n\r\n    def add_temporal_constraint(self, task_id: str, before_task: str, min_duration: float = 0.0):\r\n        """Add temporal constraint: task_id must finish before before_task starts"""\r\n        if before_task not in self.temporal_constraints:\r\n            self.temporal_constraints[before_task] = []\r\n        self.temporal_constraints[before_task].append({\r\n            \'task_id\': task_id,\r\n            \'min_duration\': min_duration,\r\n            \'constraint_type\': \'before\'\r\n        })\r\n\r\n    def check_resource_availability(self, task: Task) -> bool:\r\n        """Check if required resources are available for task execution"""\r\n        required_resources = self._get_task_resources(task)\r\n        return self.resource_manager.check_availability(required_resources)\r\n\r\n    def _get_task_resources(self, task: Task) -> Dict[str, float]:\r\n        """Get resource requirements for a task"""\r\n        resources = {}\r\n\r\n        if task.type == TaskType.NAVIGATION:\r\n            resources[\'navigation_system\'] = 1.0\r\n            resources[\'battery\'] = 0.1  # 10% battery usage estimate\r\n        elif task.type == TaskType.MANIPULATION:\r\n            resources[\'manipulator\'] = 1.0\r\n            resources[\'battery\'] = 0.05\r\n        elif task.type == TaskType.PERCEPTION:\r\n            resources[\'camera\'] = 1.0\r\n            resources[\'computation\'] = 0.3\r\n\r\n        return resources\r\n\r\nclass ResourceManager:\r\n    """Manage shared resources across tasks"""\r\n\r\n    def __init__(self):\r\n        self.resource_limits = {\r\n            \'navigation_system\': 1.0,\r\n            \'manipulator\': 1.0,\r\n            \'camera\': 1.0,\r\n            \'computation\': 1.0,\r\n            \'battery\': 1.0\r\n        }\r\n        self.resource_usage = {key: 0.0 for key in self.resource_limits}\r\n        self.resource_locks = threading.Lock()\r\n\r\n    def check_availability(self, resources: Dict[str, float]) -> bool:\r\n        """Check if required resources are available"""\r\n        with self.resource_locks:\r\n            for resource, required in resources.items():\r\n                available = self.resource_limits.get(resource, 0.0) - self.resource_usage.get(resource, 0.0)\r\n                if required > available:\r\n                    return False\r\n            return True\r\n\r\n    def allocate_resources(self, task_id: str, resources: Dict[str, float]) -> bool:\r\n        """Allocate resources for a task"""\r\n        if not self.check_availability(resources):\r\n            return False\r\n\r\n        with self.resource_locks:\r\n            for resource, amount in resources.items():\r\n                self.resource_usage[resource] = self.resource_usage.get(resource, 0.0) + amount\r\n\r\n        return True\r\n\r\n    def release_resources(self, task_id: str, resources: Dict[str, float]):\r\n        """Release resources after task completion"""\r\n        with self.resource_locks:\r\n            for resource, amount in resources.items():\r\n                current_usage = self.resource_usage.get(resource, 0.0)\r\n                self.resource_usage[resource] = max(0.0, current_usage - amount)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,s.jsx)(n.h3,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import unittest\r\nfrom unittest.mock import Mock, patch\r\n\r\nclass TestTaskPlanner(unittest.TestCase):\r\n    def setUp(self):\r\n        self.planner = TaskPlanner()\r\n\r\n    def test_task_decomposition(self):\r\n        \"\"\"Test task decomposition functionality\"\"\"\r\n        decomposer = TaskDecomposer()\r\n\r\n        goal = {\r\n            'type': 'pick_up_object',\r\n            'parameters': {\r\n                'object_type': 'cup',\r\n                'target_location': 'kitchen'\r\n            }\r\n        }\r\n\r\n        tasks = decomposer.decompose_goal(goal)\r\n\r\n        # Should create approach, detect, and grasp tasks\r\n        self.assertEqual(len(tasks), 3)\r\n        self.assertTrue(all(task.type in [TaskType.NAVIGATION, TaskType.PERCEPTION, TaskType.MANIPULATION]\r\n                          for task in tasks))\r\n\r\n    def test_task_dependencies(self):\r\n        \"\"\"Test task dependency management\"\"\"\r\n        task1 = Task(id='task1', type=TaskType.NAVIGATION, goal={}, dependencies=[])\r\n        task2 = Task(id='task2', type=TaskType.PERCEPTION, goal={}, dependencies=['task1'])\r\n\r\n        self.planner.add_tasks([task1, task2])\r\n\r\n        # Initially, only task1 should be ready\r\n        ready_task = self.planner.get_next_task()\r\n        self.assertEqual(ready_task.id, 'task1')\r\n\r\n        # After completing task1, task2 should be ready\r\n        self.planner.update_task_status('task1', TaskStatus.SUCCESS)\r\n        ready_task = self.planner.get_next_task()\r\n        self.assertEqual(ready_task.id, 'task2')\r\n\r\nclass TestTaskExecutor(unittest.TestCase):\r\n    def setUp(self):\r\n        self.executor = TaskExecutor()\r\n\r\n    @patch('rospy.Publisher')\r\n    def test_navigation_execution(self, mock_pub):\r\n        \"\"\"Test navigation task execution\"\"\"\r\n        task = Task(\r\n            id='nav_task',\r\n            type=TaskType.NAVIGATION,\r\n            goal={'target_location': 'kitchen'},\r\n            dependencies=[]\r\n        )\r\n\r\n        result = self.executor._execute_navigation_task(task)\r\n\r\n        # Should publish navigation goal\r\n        mock_pub.return_value.publish.assert_called_once()\r\n        self.assertTrue(result['success'])\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class TaskPlanningIntegrationTest:\r\n    def __init__(self):\r\n        rospy.init_node('task_planning_integration_test')\r\n        self.planner = TaskPlanner()\r\n        self.decomposer = TaskDecomposer()\r\n\r\n    def test_complete_task_pipeline(self):\r\n        \"\"\"Test complete task planning and execution pipeline\"\"\"\r\n        # Define a complex goal\r\n        goal = {\r\n            'type': 'pick_up_object',\r\n            'parameters': {\r\n                'object_type': 'red_cup',\r\n                'target_location': 'kitchen'\r\n            },\r\n            'priority': 1\r\n        }\r\n\r\n        # Decompose goal\r\n        tasks = self.decomposer.decompose_goal(goal)\r\n        print(f\"Decomposed into {len(tasks)} tasks\")\r\n\r\n        # Add tasks to planner\r\n        self.planner.add_tasks(tasks)\r\n\r\n        # Execute tasks (this would normally be done asynchronously)\r\n        completed_tasks = 0\r\n        while completed_tasks < len(tasks):\r\n            next_task = self.planner.get_next_task()\r\n            if next_task:\r\n                # Simulate task execution\r\n                print(f\"Executing task: {next_task.id} ({next_task.type.value})\")\r\n                self.planner.update_task_status(next_task.id, TaskStatus.SUCCESS)\r\n                completed_tasks += 1\r\n            else:\r\n                print(\"No tasks ready for execution\")\r\n                break\r\n\r\n        print(f\"Completed {completed_tasks} out of {len(tasks)} tasks\")\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,s.jsx)(n.h3,{id:"planning-performance",children:"Planning Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Decomposition"}),": < 50ms for simple tasks, < 200ms for complex tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan Generation"}),": < 100ms for plans with up to 10 tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Replanning"}),": < 300ms when failures occur"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Usage"}),": < 100MB for typical operation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"execution-performance",children:"Execution Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Switching"}),": < 10ms between tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Status Updates"}),": < 50ms latency for status feedback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Management"}),": < 1ms for resource checks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concurrency"}),": Support for up to 5 simultaneous tasks"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-and-common-issues",children:"Troubleshooting and Common Issues"}),"\n",(0,s.jsx)(n.h3,{id:"planning-problems",children:"Planning Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cyclic Dependencies"}),": Ensure task dependencies don't create cycles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Deadlocks"}),": Implement resource allocation timeouts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Infinite Loops"}),": Add iteration limits to planning algorithms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inconsistent States"}),": Maintain state consistency across failures"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"execution-problems",children:"Execution Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Synchronization"}),": Ensure proper coordination between systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeout Management"}),": Handle timeouts gracefully with recovery"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Propagation"}),": Prevent errors from cascading through the system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Conflicts"}),": Manage shared resources effectively"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"design-principles",children:"Design Principles"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity"}),": Keep planning, execution, and monitoring separate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extensibility"}),": Design for easy addition of new task types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Robustness"}),": Handle failures gracefully with recovery mechanisms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficiency"}),": Optimize for real-time performance requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fail-Safe"}),": Ensure safe robot state when planning fails"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Validate all generated plans before execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring"}),": Continuously monitor execution for safety violations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Emergency Stop"}),": Implement emergency task termination"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"maintainability",children:"Maintainability"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logging"}),": Comprehensive logging for debugging and analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration"}),": Use parameter server for configurable behaviors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing"}),": Maintain high test coverage for all components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": Document all interfaces and behaviors clearly"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps-and-integration",children:"Next Steps and Integration"}),"\n",(0,s.jsx)(n.h3,{id:"integration-with-other-capstone-components",children:"Integration with Other Capstone Components"}),"\n",(0,s.jsx)(n.p,{children:"The task planning system integrates with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Voice Processing"}),": Receives high-level goals and commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Navigation System"}),": Plans and monitors mobility tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manipulation System"}),": Coordinates object interaction tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Perception System"}),": Requests and processes environmental information"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Failure Handling"}),": Works with error recovery mechanisms"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,s.jsx)(n.p,{children:"Consider implementing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Learning-Based Planning"}),": Adapt planning based on execution experience"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Robot Coordination"}),": Coordinate tasks across multiple robots"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Temporal Planning"}),": Handle time-dependent task constraints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Optimization"}),": Optimize resource usage across tasks"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Continue with ",(0,s.jsx)(n.a,{href:"/Book-ai-native/docs/capstone/navigation",children:"Navigation and Obstacle Avoidance"})," to explore the implementation of the navigation system that will execute the mobility tasks planned by this system."]}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsx)(n.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);