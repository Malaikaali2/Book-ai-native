"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[3413],{6418(r,e,n){n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>_,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"module-3-ai-brain/manipulation-control","title":"Manipulation Control Systems","description":"Learning Objectives","source":"@site/docs/module-3-ai-brain/manipulation-control.md","sourceDirName":"module-3-ai-brain","slug":"/module-3-ai-brain/manipulation-control","permalink":"/Book-ai-native/docs/module-3-ai-brain/manipulation-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/module-3-ai-brain/manipulation-control.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Path Planning Algorithm Implementation","permalink":"/Book-ai-native/docs/module-3-ai-brain/path-planning"},"next":{"title":"GPU Optimization Techniques","permalink":"/Book-ai-native/docs/module-3-ai-brain/gpu-optimization"}}');var o=n(4848),a=n(8453);const i={sidebar_position:6},s="Manipulation Control Systems",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Manipulation Control",id:"introduction-to-manipulation-control",level:2},{value:"Robotic Arm Kinematics",id:"robotic-arm-kinematics",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Grasping Strategies",id:"grasping-strategies",level:2},{value:"Grasp Planning",id:"grasp-planning",level:3},{value:"Adaptive Grasping",id:"adaptive-grasping",level:3},{value:"Force Control and Compliance",id:"force-control-and-compliance",level:2},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Hybrid Position/Force Control",id:"hybrid-positionforce-control",level:3},{value:"Isaac ROS Manipulation Integration",id:"isaac-ros-manipulation-integration",level:2},{value:"Isaac ROS Manipulation Packages",id:"isaac-ros-manipulation-packages",level:3},{value:"Tactile Sensing Integration",id:"tactile-sensing-integration",level:2},{value:"Tactile Feedback for Dexterity",id:"tactile-feedback-for-dexterity",level:3},{value:"Manipulation Task Planning",id:"manipulation-task-planning",level:2},{value:"Task and Motion Planning (TAMP)",id:"task-and-motion-planning-tamp",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function p(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"manipulation-control-systems",children:"Manipulation Control Systems"})}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Design control systems for robotic manipulators and end-effectors"}),"\n",(0,o.jsx)(e.li,{children:"Implement inverse kinematics for multi-joint robotic arms"}),"\n",(0,o.jsx)(e.li,{children:"Create grasping and manipulation strategies for various objects"}),"\n",(0,o.jsx)(e.li,{children:"Integrate tactile and force feedback for dexterous manipulation"}),"\n",(0,o.jsx)(e.li,{children:"Develop control algorithms that combine vision and touch sensing"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-manipulation-control",children:"Introduction to Manipulation Control"}),"\n",(0,o.jsx)(e.p,{children:"Robotic manipulation is the capability of a robot to physically interact with objects in its environment. This involves perceiving objects, planning manipulation actions, and executing precise control commands to achieve desired outcomes. Manipulation control systems bridge the gap between perception and action, enabling robots to grasp, move, assemble, and manipulate objects with human-like dexterity."}),"\n",(0,o.jsx)(e.p,{children:"Manipulation tasks can be categorized into several types:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Grasping"}),": Acquiring and holding objects securely"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Transport"}),": Moving objects from one location to another"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Assembly"}),": Combining parts to create structures or products"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Deformable manipulation"}),": Handling flexible or soft materials"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Tool use"}),": Using objects as tools to perform tasks"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"robotic-arm-kinematics",children:"Robotic Arm Kinematics"}),"\n",(0,o.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Forward kinematics calculates the end-effector position and orientation given joint angles. For a robotic arm with n joints:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"T = T1(\u03b81) * T2(\u03b82) * ... * Tn(\u03b8n)\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where T is the transformation matrix representing the end-effector pose, and Ti(\u03b8i) represents the transformation due to joint i."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\n\r\nclass ForwardKinematics:\r\n    def __init__(self, dh_parameters):\r\n        """\r\n        Initialize with Denavit-Hartenberg parameters\r\n        dh_parameters: list of [a, alpha, d, theta_offset] for each joint\r\n        """\r\n        self.dh_params = dh_parameters\r\n\r\n    def dh_transform(self, a, alpha, d, theta):\r\n        """Calculate Denavit-Hartenberg transformation matrix"""\r\n        ct = np.cos(theta)\r\n        st = np.sin(theta)\r\n        ca = np.cos(alpha)\r\n        sa = np.sin(alpha)\r\n\r\n        transform = np.array([\r\n            [ct, -st * ca, st * sa, a * ct],\r\n            [st, ct * ca, -ct * sa, a * st],\r\n            [0, sa, ca, d],\r\n            [0, 0, 0, 1]\r\n        ])\r\n        return transform\r\n\r\n    def calculate_pose(self, joint_angles):\r\n        """Calculate end-effector pose given joint angles"""\r\n        transform = np.eye(4)  # Identity matrix\r\n\r\n        for i, (a, alpha, d, theta_offset) in enumerate(self.dh_params):\r\n            theta = joint_angles[i] + theta_offset\r\n            joint_transform = self.dh_transform(a, alpha, d, theta)\r\n            transform = transform @ joint_transform\r\n\r\n        # Extract position and orientation\r\n        position = transform[:3, 3]\r\n        rotation_matrix = transform[:3, :3]\r\n        orientation = R.from_matrix(rotation_matrix).as_quat()\r\n\r\n        return position, orientation\n'})}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Inverse kinematics (IK) solves the more complex problem of finding joint angles to achieve a desired end-effector pose. This is essential for manipulation control."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class InverseKinematics:\r\n    def __init__(self, robot_model):\r\n        self.robot = robot_model\r\n\r\n    def analytical_ik(self, target_pose, current_joints):\r\n        """\r\n        Analytical inverse kinematics for simple robot configurations\r\n        For a 6-DOF robot, this would involve geometric solutions\r\n        """\r\n        # This is a simplified example for a 2-DOF planar arm\r\n        target_pos = target_pose[:2]  # x, y position\r\n        current_pos = self.forward_kinematics(current_joints)[:2]\r\n\r\n        # Calculate joint angles using geometric relationships\r\n        x, y = target_pos\r\n        l1, l2 = self.robot.link_lengths  # Link lengths\r\n\r\n        # Distance from base to target\r\n        r = np.sqrt(x**2 + y**2)\r\n\r\n        # Check if target is reachable\r\n        if r > l1 + l2:\r\n            # Target is out of reach, extend towards it\r\n            scale = (l1 + l2) / r\r\n            x *= scale\r\n            y *= scale\r\n            r = l1 + l2\r\n        elif r < abs(l1 - l2):\r\n            # Target is inside workspace, extend towards it\r\n            scale = abs(l1 - l2) / r\r\n            x *= scale\r\n            y *= scale\r\n            r = abs(l1 - l2)\r\n\r\n        # Calculate joint angles\r\n        cos_angle2 = (l1**2 + l2**2 - r**2) / (2 * l1 * l2)\r\n        angle2 = np.arccos(np.clip(cos_angle2, -1, 1))\r\n\r\n        k1 = l1 + l2 * np.cos(angle2)\r\n        k2 = l2 * np.sin(angle2)\r\n        angle1 = np.arctan2(y, x) - np.arctan2(k2, k1)\r\n\r\n        return [angle1, angle2]\r\n\r\n    def numerical_ik(self, target_pose, current_joints, max_iterations=100, tolerance=1e-4):\r\n        """\r\n        Numerical inverse kinematics using Jacobian transpose method\r\n        """\r\n        joints = np.array(current_joints)\r\n\r\n        for i in range(max_iterations):\r\n            # Calculate current end-effector pose\r\n            current_pose = self.forward_kinematics(joints)\r\n\r\n            # Calculate error\r\n            error = target_pose - current_pose\r\n            if np.linalg.norm(error) < tolerance:\r\n                return joints\r\n\r\n            # Calculate Jacobian\r\n            jacobian = self.calculate_jacobian(joints)\r\n\r\n            # Update joint angles using Jacobian transpose\r\n            joints_delta = np.linalg.pinv(jacobian) @ error\r\n            joints += 0.1 * joints_delta  # Learning rate\r\n\r\n        return joints\r\n\r\n    def calculate_jacobian(self, joints):\r\n        """Calculate geometric Jacobian matrix"""\r\n        # Calculate Jacobian using partial derivatives\r\n        # This is a simplified version - full implementation would be more complex\r\n        pass\r\n\r\n    def forward_kinematics(self, joints):\r\n        """Calculate forward kinematics (simplified)"""\r\n        # Implementation would depend on specific robot model\r\n        pass\n'})}),"\n",(0,o.jsx)(e.h2,{id:"grasping-strategies",children:"Grasping Strategies"}),"\n",(0,o.jsx)(e.h3,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,o.jsx)(e.p,{children:"Grasp planning involves determining where and how to grasp an object for stable manipulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class GraspPlanner:\r\n    def __init__(self, robot_gripper):\r\n        self.gripper = robot_gripper\r\n        self.approach_directions = [\r\n            [0, 0, 1],   # From above\r\n            [0, 0, -1],  # From below\r\n            [1, 0, 0],   # From side\r\n            [-1, 0, 0],  # From opposite side\r\n            [0, 1, 0],   # From front\r\n            [0, -1, 0]   # From back\r\n        ]\r\n\r\n    def plan_grasp(self, object_mesh, object_pose):\r\n        """Plan stable grasp for given object"""\r\n        # Extract object features from mesh\r\n        contact_points = self.find_contact_points(object_mesh)\r\n        grasp_candidates = []\r\n\r\n        for point in contact_points:\r\n            for approach_dir in self.approach_directions:\r\n                grasp = self.evaluate_grasp(point, approach_dir, object_mesh, object_pose)\r\n                if grasp and grasp[\'quality\'] > 0.5:  # Minimum quality threshold\r\n                    grasp_candidates.append(grasp)\r\n\r\n        # Sort by quality and return best grasp\r\n        if grasp_candidates:\r\n            best_grasp = max(grasp_candidates, key=lambda g: g[\'quality\'])\r\n            return best_grasp\r\n\r\n        return None\r\n\r\n    def find_contact_points(self, object_mesh):\r\n        """Find potential contact points on object surface"""\r\n        # This would typically use mesh analysis or point cloud processing\r\n        # For simplicity, return some sample points\r\n        return [\r\n            [0.1, 0.1, 0.1],\r\n            [-0.1, 0.1, 0.1],\r\n            [0.1, -0.1, 0.1],\r\n            [-0.1, -0.1, 0.1]\r\n        ]\r\n\r\n    def evaluate_grasp(self, contact_point, approach_dir, object_mesh, object_pose):\r\n        """Evaluate grasp quality at given contact point"""\r\n        # Transform contact point to world coordinates\r\n        world_point = self.transform_point(contact_point, object_pose)\r\n\r\n        # Check if approach direction is feasible\r\n        if not self.is_approach_feasible(world_point, approach_dir):\r\n            return None\r\n\r\n        # Calculate grasp quality metrics\r\n        quality = self.calculate_grasp_quality(\r\n            world_point, approach_dir, object_mesh, object_pose\r\n        )\r\n\r\n        return {\r\n            \'position\': world_point,\r\n            \'approach_direction\': approach_dir,\r\n            \'grasp_quality\': quality,\r\n            \'gripper_width\': self.calculate_gripper_width(contact_point, object_mesh)\r\n        }\r\n\r\n    def calculate_grasp_quality(self, contact_point, approach_dir, object_mesh, object_pose):\r\n        """Calculate grasp quality metric"""\r\n        # Quality factors:\r\n        # - Force closure (ability to resist external forces)\r\n        # - Grasp stability\r\n        # - Accessibility\r\n        # - Object properties (friction, weight)\r\n\r\n        # Simplified quality calculation\r\n        quality = 0.7  # Default quality\r\n        return quality\r\n\r\n    def transform_point(self, point, pose):\r\n        """Transform point from object frame to world frame"""\r\n        # Apply rotation and translation from pose\r\n        rotation_matrix = R.from_quat(pose.orientation).as_matrix()\r\n        world_point = rotation_matrix @ point + pose.position\r\n        return world_point\r\n\r\n    def is_approach_feasible(self, point, approach_dir):\r\n        """Check if approach direction is kinematically feasible"""\r\n        # Check if approach direction would cause self-collision\r\n        # Check if approach direction is within joint limits\r\n        return True  # Simplified for example\r\n\r\n    def calculate_gripper_width(self, contact_point, object_mesh):\r\n        """Calculate required gripper width for grasp"""\r\n        # This would analyze the object geometry at the contact point\r\n        return 0.05  # 5cm default\n'})}),"\n",(0,o.jsx)(e.h3,{id:"adaptive-grasping",children:"Adaptive Grasping"}),"\n",(0,o.jsx)(e.p,{children:"Adaptive grasping adjusts grip force and strategy based on object properties:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class AdaptiveGraspController:\r\n    def __init__(self, gripper, force_sensor):\r\n        self.gripper = gripper\r\n        self.force_sensor = force_sensor\r\n        self.current_object_properties = None\r\n\r\n    def execute_adaptive_grasp(self, grasp_pose, object_properties):\r\n        """Execute grasp with adaptive force control"""\r\n        self.current_object_properties = object_properties\r\n\r\n        # Move to pre-grasp position\r\n        pre_grasp_pose = self.calculate_pre_grasp_pose(grasp_pose)\r\n        self.move_to_pose(pre_grasp_pose)\r\n\r\n        # Approach object\r\n        self.approach_object(grasp_pose)\r\n\r\n        # Close gripper with adaptive force\r\n        grip_force = self.calculate_adaptive_force(object_properties)\r\n        self.close_gripper_with_force(grip_force)\r\n\r\n        # Verify grasp success\r\n        if self.verify_grasp_success():\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    def calculate_adaptive_force(self, object_properties):\r\n        """Calculate appropriate grip force based on object properties"""\r\n        # Factors affecting grip force:\r\n        # - Object weight\r\n        # - Surface friction\r\n        # - Object fragility\r\n        # - Desired safety margin\r\n\r\n        base_force = 5.0  # Base grip force in Newtons\r\n\r\n        # Adjust for object weight\r\n        weight_factor = object_properties.get(\'weight\', 1.0) * 9.81  # weight * gravity\r\n        base_force += weight_factor * 0.5  # Add 50% of weight as additional force\r\n\r\n        # Adjust for fragility\r\n        fragility_factor = object_properties.get(\'fragility\', 1.0)\r\n        if fragility_factor < 0.5:\r\n            # Fragile object - use minimum force\r\n            base_force = min(base_force, 2.0)\r\n        elif fragility_factor > 1.5:\r\n            # Robust object - can use higher force\r\n            base_force *= 1.5\r\n\r\n        # Adjust for surface friction\r\n        friction_factor = object_properties.get(\'friction\', 0.5)\r\n        if friction_factor < 0.3:\r\n            # Low friction - need higher grip force\r\n            base_force *= 1.8\r\n        elif friction_factor > 0.7:\r\n            # High friction - can use lower force\r\n            base_force *= 0.7\r\n\r\n        # Ensure within gripper limits\r\n        max_force = self.gripper.max_force\r\n        min_force = self.gripper.min_force\r\n        grip_force = np.clip(base_force, min_force, max_force)\r\n\r\n        return grip_force\r\n\r\n    def verify_grasp_success(self):\r\n        """Verify that grasp was successful"""\r\n        # Check force sensor readings\r\n        force_readings = self.force_sensor.get_readings()\r\n\r\n        # Look for characteristic patterns of successful grasp\r\n        if len(force_readings) > 10:\r\n            recent_forces = force_readings[-10:]\r\n            avg_force = np.mean(recent_forces)\r\n\r\n            # Successful grasp typically shows stable force readings\r\n            if avg_force > 0.5 and np.std(recent_forces) < 0.2:\r\n                return True\r\n\r\n        return False\r\n\r\n    def calculate_pre_grasp_pose(self, grasp_pose):\r\n        """Calculate safe pre-grasp pose"""\r\n        # Move 10cm away from grasp point along approach direction\r\n        approach_dir = grasp_pose[\'approach_direction\']\r\n        pre_grasp_offset = np.array(approach_dir) * 0.1  # 10cm offset\r\n        pre_grasp_pos = np.array(grasp_pose[\'position\']) - pre_grasp_offset\r\n\r\n        return {\r\n            \'position\': pre_grasp_pos,\r\n            \'orientation\': grasp_pose[\'orientation\']\r\n        }\r\n\r\n    def approach_object(self, grasp_pose):\r\n        """Approach object with controlled motion"""\r\n        # Use Cartesian impedance control for safe approach\r\n        self.move_to_pose(grasp_pose, control_mode=\'impedance\')\r\n\r\n    def close_gripper_with_force(self, target_force):\r\n        """Close gripper while monitoring applied force"""\r\n        current_force = 0\r\n        while current_force < target_force:\r\n            self.gripper.close_incrementally()\r\n            current_force = self.force_sensor.get_gripper_force()\r\n\r\n            if current_force > target_force:\r\n                # Apply force control to maintain target force\r\n                self.gripper.set_force_control(target_force)\r\n                break\n'})}),"\n",(0,o.jsx)(e.h2,{id:"force-control-and-compliance",children:"Force Control and Compliance"}),"\n",(0,o.jsx)(e.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,o.jsx)(e.p,{children:"Impedance control makes the robot behave like a virtual spring-damper system, providing compliant behavior:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class ImpedanceController:\r\n    def __init__(self, robot, stiffness=1000, damping=20):\r\n        self.robot = robot\r\n        self.stiffness = stiffness  # N/m\r\n        self.damping = damping      # Ns/m\r\n        self.desired_pose = None\r\n        self.mass = 1.0  # Effective mass (kg)\r\n\r\n    def set_desired_pose(self, pose):\r\n        """Set desired pose for impedance control"""\r\n        self.desired_pose = pose\r\n\r\n    def compute_impedance_force(self, current_pose, current_velocity):\r\n        """Compute impedance force based on position and velocity errors"""\r\n        if self.desired_pose is None:\r\n            return np.zeros(6)  # 6 DOF: 3 for position, 3 for orientation\r\n\r\n        # Calculate position and velocity errors\r\n        pos_error = current_pose[:3] - self.desired_pose[:3]\r\n        vel_error = current_velocity[:3]\r\n\r\n        # Compute impedance force: F = K * error_pos + D * error_vel\r\n        position_force = -self.stiffness * pos_error\r\n        velocity_force = -self.damping * vel_error\r\n\r\n        # Combine forces\r\n        total_force = position_force + velocity_force\r\n\r\n        # For orientation, similar approach with rotation errors\r\n        orientation_error = self.calculate_rotation_error(\r\n            current_pose[3:], self.desired_pose[3:]\r\n        )\r\n        orientation_force = -self.stiffness * orientation_error\r\n\r\n        return np.concatenate([total_force, orientation_force])\r\n\r\n    def calculate_rotation_error(self, current_quat, desired_quat):\r\n        """Calculate rotation error between two quaternions"""\r\n        # Convert quaternions to rotation vectors for error calculation\r\n        current_rot = R.from_quat(current_quat).as_rotvec()\r\n        desired_rot = R.from_quat(desired_quat).as_rotvec()\r\n        return desired_rot - current_rot\r\n\r\n    def update_impedance_parameters(self, stiffness=None, damping=None):\r\n        """Update impedance parameters during operation"""\r\n        if stiffness is not None:\r\n            self.stiffness = stiffness\r\n        if damping is not None:\r\n            self.damping = damping\n'})}),"\n",(0,o.jsx)(e.h3,{id:"hybrid-positionforce-control",children:"Hybrid Position/Force Control"}),"\n",(0,o.jsx)(e.p,{children:"Hybrid control combines position and force control for complex manipulation tasks:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class HybridPositionForceController:\r\n    def __init__(self, robot, contact_surface_normal=None):\r\n        self.robot = robot\r\n        self.contact_surface_normal = contact_surface_normal or np.array([0, 0, 1])\r\n        self.position_gains = {'P': 100, 'I': 0.1, 'D': 10}\r\n        self.force_gains = {'P': 50, 'I': 0.05, 'D': 5}\r\n\r\n    def hybrid_control(self, desired_pos, desired_force, current_pos, current_force):\r\n        \"\"\"\r\n        Implement hybrid position/force control\r\n        Position control along unconstrained directions\r\n        Force control along constrained directions\r\n        \"\"\"\r\n        # Define constraint matrix based on contact surface\r\n        constraint_matrix = self.calculate_constraint_matrix()\r\n\r\n        # Calculate errors\r\n        pos_error = desired_pos - current_pos\r\n        force_error = desired_force - current_force\r\n\r\n        # Apply control in constrained vs unconstrained directions\r\n        control_commands = np.zeros(6)  # 6 DOF\r\n\r\n        for i in range(6):\r\n            if constraint_matrix[i] == 0:  # Position controlled direction\r\n                control_commands[i] = (\r\n                    self.position_gains['P'] * pos_error[i] +\r\n                    self.position_gains['I'] * self.integrate_pos_error[i] +\r\n                    self.position_gains['D'] * self.derivative_pos_error[i]\r\n                )\r\n            else:  # Force controlled direction\r\n                control_commands[i] = (\r\n                    self.force_gains['P'] * force_error[i] +\r\n                    self.force_gains['I'] * self.integrate_force_error[i] +\r\n                    self.force_gains['D'] * self.derivative_force_error[i]\r\n                )\r\n\r\n        return control_commands\r\n\r\n    def calculate_constraint_matrix(self):\r\n        \"\"\"\r\n        Calculate constraint matrix based on contact geometry\r\n        0 = position controlled, 1 = force controlled\r\n        \"\"\"\r\n        # For planar contact, typically constrain normal force, allow tangential motion\r\n        constraint_matrix = np.array([0, 0, 1, 0, 0, 0])  # Constrain z-force, allow x,y position\r\n        return constraint_matrix\n"})}),"\n",(0,o.jsx)(e.h2,{id:"isaac-ros-manipulation-integration",children:"Isaac ROS Manipulation Integration"}),"\n",(0,o.jsx)(e.h3,{id:"isaac-ros-manipulation-packages",children:"Isaac ROS Manipulation Packages"}),"\n",(0,o.jsx)(e.p,{children:"Isaac provides specialized packages for manipulation tasks:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Pose, Point\r\nfrom sensor_msgs.msg import JointState\r\nfrom control_msgs.msg import JointTrajectoryControllerState\r\nfrom std_msgs.msg import Float64MultiArray\r\nfrom visualization_msgs.msg import Marker\r\n\r\nclass IsaacManipulationController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_manipulation_controller\')\r\n\r\n        # Publishers for Isaac manipulation\r\n        self.joint_command_publisher = self.create_publisher(\r\n            JointState, \'isaac_manipulator/joint_commands\', 10\r\n        )\r\n\r\n        self.trajectory_publisher = self.create_publisher(\r\n            JointState, \'isaac_manipulator/trajectory_commands\', 10\r\n        )\r\n\r\n        self.visualization_publisher = self.create_publisher(\r\n            Marker, \'manipulation_visualization\', 10\r\n        )\r\n\r\n        # Subscribers\r\n        self.joint_state_subscriber = self.create_subscription(\r\n            JointState, \'isaac_manipulator/joint_states\', self.joint_state_callback, 10\r\n        )\r\n\r\n        self.ee_pose_subscriber = self.create_subscription(\r\n            Pose, \'isaac_manipulator/ee_pose\', self.ee_pose_callback, 10\r\n        )\r\n\r\n        # Isaac-specific manipulation services\r\n        self.ik_service_client = self.create_client(\r\n            ComputeIK, \'isaac_compute_ik\'\r\n        )\r\n\r\n        self.grasp_service_client = self.create_client(\r\n            ExecuteGrasp, \'isaac_execute_grasp\'\r\n        )\r\n\r\n        # Initialize controllers\r\n        self.current_joint_state = None\r\n        self.current_ee_pose = None\r\n        self.impedance_controller = ImpedanceController(self)\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Handle incoming joint state messages"""\r\n        self.current_joint_state = msg\r\n\r\n    def ee_pose_callback(self, msg):\r\n        """Handle incoming end-effector pose messages"""\r\n        self.current_ee_pose = msg\r\n\r\n    def move_to_pose(self, target_pose, method=\'ik\'):\r\n        """Move manipulator to target pose using inverse kinematics"""\r\n        if method == \'ik\':\r\n            # Use Isaac\'s IK service\r\n            if self.ik_service_client.wait_for_service(timeout_sec=1.0):\r\n                request = ComputeIK.Request()\r\n                request.target_pose = target_pose\r\n                request.current_joints = self.current_joint_state\r\n\r\n                future = self.ik_service_client.call_async(request)\r\n                future.add_done_callback(self.ik_response_callback)\r\n            else:\r\n                self.get_logger().error(\'IK service not available\')\r\n\r\n    def ik_response_callback(self, future):\r\n        """Handle IK service response"""\r\n        try:\r\n            response = future.result()\r\n            if response.success:\r\n                # Execute joint trajectory\r\n                self.execute_joint_trajectory(response.joint_angles)\r\n            else:\r\n                self.get_logger().error(\'IK solution not found\')\r\n        except Exception as e:\r\n            self.get_logger().error(f\'IK service call failed: {e}\')\r\n\r\n    def execute_grasp(self, grasp_pose, object_properties):\r\n        """Execute grasp using Isaac\'s manipulation capabilities"""\r\n        if self.grasp_service_client.wait_for_service(timeout_sec=1.0):\r\n            request = ExecuteGrasp.Request()\r\n            request.grasp_pose = grasp_pose\r\n            request.object_properties = self.dict_to_msg(object_properties)\r\n\r\n            future = self.grasp_service_client.call_async(request)\r\n            future.add_done_callback(self.grasp_response_callback)\r\n        else:\r\n            self.get_logger().error(\'Grasp service not available\')\r\n\r\n    def execute_joint_trajectory(self, joint_angles, duration=5.0):\r\n        """Execute joint trajectory to reach target joint angles"""\r\n        trajectory_msg = JointState()\r\n        trajectory_msg.name = [\'joint1\', \'joint2\', \'joint3\', \'joint4\', \'joint5\', \'joint6\']\r\n        trajectory_msg.position = joint_angles\r\n        trajectory_msg.velocity = [0.0] * len(joint_angles)  # Start/stop with zero velocity\r\n        trajectory_msg.effort = [0.0] * len(joint_angles)\r\n\r\n        # Publish trajectory command\r\n        self.trajectory_publisher.publish(trajectory_msg)\r\n\r\n    def visualize_grasp_candidate(self, grasp_pose):\r\n        """Visualize grasp candidate in RViz"""\r\n        marker = Marker()\r\n        marker.header.frame_id = \'base_link\'\r\n        marker.header.stamp = self.get_clock().now().to_msg()\r\n        marker.ns = \'grasp_candidates\'\r\n        marker.id = 0\r\n        marker.type = Marker.ARROW\r\n        marker.action = Marker.ADD\r\n\r\n        # Set arrow properties to represent grasp\r\n        marker.pose = grasp_pose\r\n        marker.scale.x = 0.1  # Arrow length\r\n        marker.scale.y = 0.02  # Arrow width\r\n        marker.scale.z = 0.02  # Arrow height\r\n        marker.color.r = 1.0\r\n        marker.color.g = 0.0\r\n        marker.color.b = 0.0\r\n        marker.color.a = 1.0\r\n\r\n        self.visualization_publisher.publish(marker)\r\n\r\n    def dict_to_msg(self, properties_dict):\r\n        """Convert dictionary to ROS message (simplified)"""\r\n        # This would convert the dictionary to appropriate ROS message type\r\n        pass\n'})}),"\n",(0,o.jsx)(e.h2,{id:"tactile-sensing-integration",children:"Tactile Sensing Integration"}),"\n",(0,o.jsx)(e.h3,{id:"tactile-feedback-for-dexterity",children:"Tactile Feedback for Dexterity"}),"\n",(0,o.jsx)(e.p,{children:"Tactile sensors provide crucial feedback for dexterous manipulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class TactileFeedbackController:\r\n    def __init__(self, tactile_sensors, gripper):\r\n        self.tactile_sensors = tactile_sensors\r\n        self.gripper = gripper\r\n        self.contact_threshold = 0.1  # Threshold for contact detection\r\n        self.slip_detection_threshold = 0.5\r\n\r\n    def monitor_tactile_feedback(self):\r\n        """Monitor tactile sensors for contact and slip detection"""\r\n        tactile_data = self.tactile_sensors.get_readings()\r\n\r\n        # Detect contact\r\n        contact_detected = self.detect_contact(tactile_data)\r\n\r\n        # Detect slip\r\n        slip_detected = self.detect_slip(tactile_data)\r\n\r\n        return {\r\n            \'contact\': contact_detected,\r\n            \'slip\': slip_detected,\r\n            \'pressure_map\': tactile_data[\'pressure\'],\r\n            \'temperature\': tactile_data[\'temperature\']\r\n        }\r\n\r\n    def detect_contact(self, tactile_data):\r\n        """Detect if object is in contact with tactile sensors"""\r\n        pressure_values = tactile_data[\'pressure\']\r\n        max_pressure = np.max(pressure_values)\r\n        return max_pressure > self.contact_threshold\r\n\r\n    def detect_slip(self, tactile_data):\r\n        """Detect slip based on tactile sensor readings"""\r\n        # Slip detection typically involves:\r\n        # - Sudden changes in pressure distribution\r\n        # - High-frequency vibrations\r\n        # - Asymmetric pressure patterns\r\n        pressure_changes = np.diff(tactile_data[\'pressure\'], axis=0)\r\n        max_change = np.max(np.abs(pressure_changes))\r\n        return max_change > self.slip_detection_threshold\r\n\r\n    def adaptive_grasp_control(self, target_force):\r\n        """Adjust grip force based on tactile feedback"""\r\n        feedback = self.monitor_tactile_feedback()\r\n\r\n        if feedback[\'slip\']:\r\n            # Increase grip force if slip detected\r\n            current_force = self.gripper.get_current_force()\r\n            new_force = min(current_force * 1.2, self.gripper.max_force)\r\n            self.gripper.set_force(new_force)\r\n        elif feedback[\'contact\']:\r\n            # Maintain stable grip force\r\n            current_force = self.gripper.get_current_force()\r\n            if abs(current_force - target_force) > 0.1:\r\n                self.gripper.set_force(target_force)\r\n\r\n    def slip_compensation(self):\r\n        """Compensate for detected slip by adjusting grip strategy"""\r\n        feedback = self.monitor_tactile_feedback()\r\n\r\n        if feedback[\'slip\']:\r\n            # Adjust grip strategy\r\n            self.gripper.increase_force_gradually()\r\n            # Consider changing grasp strategy if slip persists\r\n            return True\r\n\r\n        return False\n'})}),"\n",(0,o.jsx)(e.h2,{id:"manipulation-task-planning",children:"Manipulation Task Planning"}),"\n",(0,o.jsx)(e.h3,{id:"task-and-motion-planning-tamp",children:"Task and Motion Planning (TAMP)"}),"\n",(0,o.jsx)(e.p,{children:"Combining high-level task planning with low-level motion planning:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class TaskAndMotionPlanner:\r\n    def __init__(self, symbolic_planner, motion_planner):\r\n        self.symbolic_planner = symbolic_planner\r\n        self.motion_planner = motion_planner\r\n        self.known_objects = {}\r\n        self.robot_state = {}\r\n\r\n    def plan_manipulation_task(self, task_description):\r\n        \"\"\"\r\n        Plan manipulation task combining symbolic and motion planning\r\n        Example task: \"Pick up red block and place it on blue box\"\r\n        \"\"\"\r\n        # Step 1: Symbolic task planning\r\n        symbolic_plan = self.symbolic_planner.plan(task_description)\r\n\r\n        # Step 2: Ground symbolic actions to motion plans\r\n        motion_plan = []\r\n        for symbolic_action in symbolic_plan:\r\n            motion_primitive = self.ground_action(symbolic_action)\r\n            if motion_primitive:\r\n                motion_plan.append(motion_primitive)\r\n\r\n        return motion_plan\r\n\r\n    def ground_action(self, symbolic_action):\r\n        \"\"\"Ground symbolic action to concrete motion plan\"\"\"\r\n        action_type = symbolic_action['type']\r\n        parameters = symbolic_action['parameters']\r\n\r\n        if action_type == 'pick':\r\n            return self.plan_pick_action(parameters)\r\n        elif action_type == 'place':\r\n            return self.plan_place_action(parameters)\r\n        elif action_type == 'move_to':\r\n            return self.plan_move_action(parameters)\r\n        else:\r\n            return None\r\n\r\n    def plan_pick_action(self, params):\r\n        \"\"\"Plan pick action with grasp planning and trajectory generation\"\"\"\r\n        object_name = params['object']\r\n        object_pose = self.known_objects.get(object_name)\r\n\r\n        if not object_pose:\r\n            return None\r\n\r\n        # Plan grasp for object\r\n        grasp_planner = GraspPlanner(self.robot_state['gripper'])\r\n        grasp = grasp_planner.plan_grasp(object_pose['mesh'], object_pose['pose'])\r\n\r\n        if not grasp:\r\n            return None\r\n\r\n        # Plan approach trajectory\r\n        approach_traj = self.motion_planner.plan_trajectory(\r\n            start_pose=self.robot_state['ee_pose'],\r\n            goal_pose=grasp['approach_pose']\r\n        )\r\n\r\n        # Plan grasp execution trajectory\r\n        grasp_traj = self.motion_planner.plan_trajectory(\r\n            start_pose=grasp['approach_pose'],\r\n            goal_pose=grasp['grasp_pose']\r\n        )\r\n\r\n        return {\r\n            'action': 'pick',\r\n            'object': object_name,\r\n            'grasp': grasp,\r\n            'trajectories': [approach_traj, grasp_traj],\r\n            'gripper_command': 'close'\r\n        }\r\n\r\n    def plan_place_action(self, params):\r\n        \"\"\"Plan place action with placement planning\"\"\"\r\n        target_location = params['location']\r\n        object_name = params['object']\r\n\r\n        # Plan placement pose\r\n        placement_pose = self.calculate_placement_pose(target_location, object_name)\r\n\r\n        # Plan approach trajectory\r\n        approach_traj = self.motion_planner.plan_trajectory(\r\n            start_pose=self.robot_state['ee_pose'],\r\n            goal_pose=placement_pose['approach_pose']\r\n        )\r\n\r\n        # Plan placement trajectory\r\n        place_traj = self.motion_planner.plan_trajectory(\r\n            start_pose=placement_pose['approach_pose'],\r\n            goal_pose=placement_pose['place_pose']\r\n        )\r\n\r\n        return {\r\n            'action': 'place',\r\n            'object': object_name,\r\n            'placement_pose': placement_pose,\r\n            'trajectories': [approach_traj, place_traj],\r\n            'gripper_command': 'open'\r\n        }\r\n\r\n    def calculate_placement_pose(self, target_location, object_name):\r\n        \"\"\"Calculate safe placement pose\"\"\"\r\n        # This would consider object dimensions, target surface stability, etc.\r\n        object_dims = self.known_objects[object_name]['dimensions']\r\n        safe_height = object_dims[2] / 2  # Half object height above surface\r\n\r\n        placement_pose = {\r\n            'position': [target_location['x'], target_location['y'], target_location['z'] + safe_height],\r\n            'orientation': [0, 0, 0, 1]  # Default orientation\r\n        }\r\n\r\n        # Calculate approach pose (above placement position)\r\n        approach_pose = {\r\n            'position': [target_location['x'], target_location['y'], target_location['z'] + safe_height + 0.1],\r\n            'orientation': [0, 0, 0, 1]\r\n        }\r\n\r\n        return {\r\n            'place_pose': placement_pose,\r\n            'approach_pose': approach_pose\r\n        }\n"})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Manipulation control systems enable robots to interact with their environment through precise control of robotic arms and end-effectors. By combining kinematic models, grasp planning, force control, and tactile feedback, robots can perform complex manipulation tasks with dexterity and safety."}),"\n",(0,o.jsx)(e.p,{children:"The next section will cover GPU optimization techniques, which are essential for accelerating the computation-intensive algorithms used in manipulation control."}),"\n",(0,o.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,o.jsx)(e.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function _(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(p,{...r})}):p(r)}},8453(r,e,n){n.d(e,{R:()=>i,x:()=>s});var t=n(6540);const o={},a=t.createContext(o);function i(r){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function s(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:i(r.components),t.createElement(a.Provider,{value:e},r.children)}}}]);