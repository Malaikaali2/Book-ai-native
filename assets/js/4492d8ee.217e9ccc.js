"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[6500],{672(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-2-digital-twin/unity-simulation","title":"Unity Robotics Simulation","description":"Overview","source":"@site/docs/module-2-digital-twin/unity-simulation.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/unity-simulation","permalink":"/Book-ai-native/docs/module-2-digital-twin/unity-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Malaikaali2/Book-ai-native/tree/main/docs/module-2-digital-twin/unity-simulation.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Simulation and Modeling","permalink":"/Book-ai-native/docs/module-2-digital-twin/sensor-simulation"},"next":{"title":"Simulation-to-Reality Transfer Techniques","permalink":"/Book-ai-native/docs/module-2-digital-twin/sim-to-reality"}}');var t=r(4848),o=r(8453);const a={sidebar_position:5},s="Unity Robotics Simulation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Unity Robotics Ecosystem",id:"unity-robotics-ecosystem",level:2},{value:"1. Core Components",id:"1-core-components",level:3},{value:"Unity Robotics Hub",id:"unity-robotics-hub",level:4},{value:"ROS/ROS2 Integration",id:"rosros2-integration",level:4},{value:"2. Setup and Installation",id:"2-setup-and-installation",level:3},{value:"Prerequisites",id:"prerequisites",level:4},{value:"Installation Steps",id:"installation-steps",level:4},{value:"Creating Robotics Environments in Unity",id:"creating-robotics-environments-in-unity",level:2},{value:"1. Project Structure",id:"1-project-structure",level:3},{value:"2. Basic Robot Setup",id:"2-basic-robot-setup",level:3},{value:"Creating a Simple Robot Model",id:"creating-a-simple-robot-model",level:4},{value:"3. Environment Creation",id:"3-environment-creation",level:3},{value:"Using ProBuilder for Environment Design",id:"using-probuilder-for-environment-design",level:4},{value:"Sensor Simulation in Unity",id:"sensor-simulation-in-unity",level:2},{value:"1. Camera Sensors",id:"1-camera-sensors",level:3},{value:"2. LIDAR Simulation",id:"2-lidar-simulation",level:3},{value:"3. IMU Simulation",id:"3-imu-simulation",level:3},{value:"Unity-ROS Communication",id:"unity-ros-communication",level:2},{value:"1. Setting up ROS Connection",id:"1-setting-up-ros-connection",level:3},{value:"2. Subscribing to ROS Topics",id:"2-subscribing-to-ros-topics",level:3},{value:"Advanced Unity Robotics Features",id:"advanced-unity-robotics-features",level:2},{value:"1. ML-Agents Integration",id:"1-ml-agents-integration",level:3},{value:"2. Physics Optimization",id:"2-physics-optimization",level:3},{value:"Best Practices for Unity Robotics",id:"best-practices-for-unity-robotics",level:2},{value:"1. Performance Optimization",id:"1-performance-optimization",level:3},{value:"2. Accuracy Considerations",id:"2-accuracy-considerations",level:3},{value:"3. Integration Strategies",id:"3-integration-strategies",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Physics Issues",id:"1-physics-issues",level:3},{value:"2. Performance Issues",id:"2-performance-issues",level:3},{value:"3. ROS Connection Issues",id:"3-ros-connection-issues",level:3},{value:"Comparison with Other Simulation Platforms",id:"comparison-with-other-simulation-platforms",level:2},{value:"Unity vs. Gazebo",id:"unity-vs-gazebo",level:3},{value:"References",id:"references",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"unity-robotics-simulation",children:"Unity Robotics Simulation"})}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Unity is a powerful game engine that has been adapted for robotics simulation through the Unity Robotics ecosystem. With its advanced rendering capabilities, intuitive visual editor, and real-time physics engine, Unity provides an excellent platform for creating high-fidelity simulation environments for robotics applications."}),"\n",(0,t.jsx)(e.h2,{id:"unity-robotics-ecosystem",children:"Unity Robotics Ecosystem"}),"\n",(0,t.jsx)(e.h3,{id:"1-core-components",children:"1. Core Components"}),"\n",(0,t.jsx)(e.h4,{id:"unity-robotics-hub",children:"Unity Robotics Hub"}),"\n",(0,t.jsx)(e.p,{children:"The Unity Robotics Hub is a package manager that provides access to robotics-specific tools and packages:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unity Robotics Package (URP)"}),": Core robotics functionality for Unity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unity Machine Learning Agents (ML-Agents)"}),": Reinforcement learning platform"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS#"}),": Bridge for connecting Unity to ROS/ROS2"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ProBuilder"}),": Tools for creating 3D environments"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Visual Studio Tools"}),": Enhanced development experience"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"rosros2-integration",children:"ROS/ROS2 Integration"}),"\n",(0,t.jsx)(e.p,{children:"Unity can communicate with ROS/ROS2 through the Unity Robotics Package and ROS#:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Message Passing"}),": Send and receive ROS messages directly from Unity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Service Calls"}),": Execute ROS services from Unity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Action Servers"}),": Create action servers in Unity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"TF Transforms"}),": Publish and subscribe to transform data"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-setup-and-installation",children:"2. Setup and Installation"}),"\n",(0,t.jsx)(e.h4,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Unity Hub and Unity Editor (2021.3 LTS or newer)"}),"\n",(0,t.jsx)(e.li,{children:"Visual Studio or similar IDE"}),"\n",(0,t.jsx)(e.li,{children:"ROS/ROS2 installation (if connecting to ROS network)"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"installation-steps",children:"Installation Steps"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Download and install Unity Hub"}),"\n",(0,t.jsx)(e.li,{children:"Install Unity Editor 2021.3 LTS or newer"}),"\n",(0,t.jsx)(e.li,{children:"Create a new 3D project"}),"\n",(0,t.jsx)(e.li,{children:"Install Unity Robotics Package via Package Manager"}),"\n",(0,t.jsx)(e.li,{children:"Install ROS# if connecting to ROS/ROS2"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"creating-robotics-environments-in-unity",children:"Creating Robotics Environments in Unity"}),"\n",(0,t.jsx)(e.h3,{id:"1-project-structure",children:"1. Project Structure"}),"\n",(0,t.jsx)(e.p,{children:"A typical Unity robotics project follows this structure:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Unity Robotics Project/\r\n\u251c\u2500\u2500 Assets/\r\n\u2502   \u251c\u2500\u2500 Scenes/                 # Unity scenes\r\n\u2502   \u251c\u2500\u2500 Scripts/                # C# scripts for robotics functionality\r\n\u2502   \u251c\u2500\u2500 Models/                 # 3D models for robots/environments\r\n\u2502   \u251c\u2500\u2500 Materials/              # Material definitions\r\n\u2502   \u251c\u2500\u2500 Prefabs/                # Reusable objects\r\n\u2502   \u251c\u2500\u2500 Plugins/                # Third-party libraries\r\n\u2502   \u2514\u2500\u2500 StreamingAssets/        # Assets that need to be accessible at runtime\r\n\u251c\u2500\u2500 Packages/\r\n\u251c\u2500\u2500 ProjectSettings/\r\n\u2514\u2500\u2500 Library/\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-basic-robot-setup",children:"2. Basic Robot Setup"}),"\n",(0,t.jsx)(e.h4,{id:"creating-a-simple-robot-model",children:"Creating a Simple Robot Model"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\n[RequireComponent(typeof(Rigidbody))]\r\npublic class RobotController : MonoBehaviour\r\n{\r\n    [Header("Movement Settings")]\r\n    public float linearVelocity = 1.0f;\r\n    public float angularVelocity = 1.0f;\r\n\r\n    [Header("Components")]\r\n    public Transform leftWheel;\r\n    public Transform rightWheel;\r\n\r\n    private Rigidbody rb;\r\n    private float leftWheelSpeed = 0f;\r\n    private float rightWheelSpeed = 0f;\r\n\r\n    void Start()\r\n    {\r\n        rb = GetComponent<Rigidbody>();\r\n        rb.constraints = RigidbodyConstraints.FreezeRotationX |\r\n                         RigidbodyConstraints.FreezeRotationZ |\r\n                         RigidbodyConstraints.FreezePositionY;\r\n    }\r\n\r\n    void FixedUpdate()\r\n    {\r\n        // Differential drive kinematics\r\n        float linear = (leftWheelSpeed + rightWheelSpeed) / 2f;\r\n        float angular = (rightWheelSpeed - leftWheelSpeed) / 2f;\r\n\r\n        // Apply movement\r\n        Vector3 movement = transform.forward * linear * linearVelocity * Time.fixedDeltaTime;\r\n        rb.MovePosition(rb.position + movement);\r\n\r\n        // Apply rotation\r\n        float rotation = angular * angularVelocity * Time.fixedDeltaTime;\r\n        rb.MoveRotation(rb.rotation * Quaternion.Euler(0, rotation, 0));\r\n\r\n        // Rotate wheels visually\r\n        if (leftWheel != null)\r\n            leftWheel.Rotate(Vector3.right, leftWheelSpeed * Time.fixedDeltaTime * 100f);\r\n        if (rightWheel != null)\r\n            rightWheel.Rotate(Vector3.right, rightWheelSpeed * Time.fixedDeltaTime * 100f);\r\n    }\r\n\r\n    public void SetWheelVelocities(float left, float right)\r\n    {\r\n        leftWheelSpeed = left;\r\n        rightWheelSpeed = right;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-environment-creation",children:"3. Environment Creation"}),"\n",(0,t.jsx)(e.h4,{id:"using-probuilder-for-environment-design",children:"Using ProBuilder for Environment Design"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing ProBuilder2.MeshOperations;\r\nusing ProBuilder2.Core;\r\n\r\npublic class EnvironmentBuilder : MonoBehaviour\r\n{\r\n    [Header("Room Dimensions")]\r\n    public float roomWidth = 10f;\r\n    public float roomDepth = 10f;\r\n    public float roomHeight = 3f;\r\n\r\n    [Header("Materials")]\r\n    public Material floorMaterial;\r\n    public Material wallMaterial;\r\n\r\n    void Start()\r\n    {\r\n        BuildEnvironment();\r\n    }\r\n\r\n    void BuildEnvironment()\r\n    {\r\n        CreateFloor();\r\n        CreateWalls();\r\n        AddObstacles();\r\n    }\r\n\r\n    void CreateFloor()\r\n    {\r\n        GameObject floor = ProBuilderMesh.CreatePrimitive(ProBuilder2.Common.PrimitiveType.Cube).gameObject;\r\n        floor.transform.SetParent(transform);\r\n        floor.transform.localPosition = Vector3.zero;\r\n        floor.transform.localScale = new Vector3(roomWidth, 0.1f, roomDepth);\r\n        floor.name = "Floor";\r\n\r\n        if (floorMaterial != null)\r\n            floor.GetComponent<MeshRenderer>().material = floorMaterial;\r\n    }\r\n\r\n    void CreateWalls()\r\n    {\r\n        // Create 4 walls\r\n        for (int i = 0; i < 4; i++)\r\n        {\r\n            GameObject wall = ProBuilderMesh.CreatePrimitive(ProBuilder2.Common.PrimitiveType.Cube).gameObject;\r\n            wall.transform.SetParent(transform);\r\n\r\n            float angle = i * 90f;\r\n            wall.transform.localRotation = Quaternion.Euler(0, angle, 0);\r\n\r\n            switch (i)\r\n            {\r\n                case 0: // Front wall\r\n                    wall.transform.localPosition = new Vector3(0, roomHeight/2, roomDepth/2);\r\n                    wall.transform.localScale = new Vector3(roomWidth, roomHeight, 0.1f);\r\n                    break;\r\n                case 1: // Right wall\r\n                    wall.transform.localPosition = new Vector3(roomWidth/2, roomHeight/2, 0);\r\n                    wall.transform.localScale = new Vector3(0.1f, roomHeight, roomDepth);\r\n                    break;\r\n                case 2: // Back wall\r\n                    wall.transform.localPosition = new Vector3(0, roomHeight/2, -roomDepth/2);\r\n                    wall.transform.localScale = new Vector3(roomWidth, roomHeight, 0.1f);\r\n                    break;\r\n                case 3: // Left wall\r\n                    wall.transform.localPosition = new Vector3(-roomWidth/2, roomHeight/2, 0);\r\n                    wall.transform.localScale = new Vector3(0.1f, roomHeight, roomDepth);\r\n                    break;\r\n            }\r\n\r\n            wall.name = $"Wall_{i}";\r\n            if (wallMaterial != null)\r\n                wall.GetComponent<MeshRenderer>().material = wallMaterial;\r\n        }\r\n    }\r\n\r\n    void AddObstacles()\r\n    {\r\n        // Add some obstacles\r\n        for (int i = 0; i < 5; i++)\r\n        {\r\n            GameObject obstacle = GameObject.CreatePrimitive(PrimitiveType.Cylinder);\r\n            obstacle.transform.SetParent(transform);\r\n            obstacle.transform.position = new Vector3(\r\n                Random.Range(-roomWidth/2 + 1, roomWidth/2 - 1),\r\n                0.5f,\r\n                Random.Range(-roomDepth/2 + 1, roomDepth/2 - 1)\r\n            );\r\n            obstacle.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);\r\n            obstacle.name = $"Obstacle_{i}";\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"sensor-simulation-in-unity",children:"Sensor Simulation in Unity"}),"\n",(0,t.jsx)(e.h3,{id:"1-camera-sensors",children:"1. Camera Sensors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing System.Collections;\r\nusing Unity.Robotics.ROSTCPConnector;\r\nusing RosMessageTypes.Sensor;\r\nusing RosMessageTypes.Std;\r\n\r\npublic class UnityCameraSensor : MonoBehaviour\r\n{\r\n    public Camera sensorCamera;\r\n    public string topicName = "/camera/image_raw";\r\n    public int imageWidth = 640;\r\n    public int imageHeight = 480;\r\n    public float updateRate = 30f;\r\n\r\n    private ROSConnection ros;\r\n    private RenderTexture renderTexture;\r\n    private float updateInterval;\r\n    private float lastUpdateTime;\r\n\r\n    void Start()\r\n    {\r\n        ros = ROSConnection.GetOrCreateInstance();\r\n        SetupCamera();\r\n        updateInterval = 1.0f / updateRate;\r\n        lastUpdateTime = 0f;\r\n    }\r\n\r\n    void SetupCamera()\r\n    {\r\n        if (sensorCamera == null)\r\n            sensorCamera = GetComponent<Camera>();\r\n\r\n        sensorCamera.fieldOfView = 60f; // 60 degree FOV\r\n        renderTexture = new RenderTexture(imageWidth, imageHeight, 24);\r\n        sensorCamera.targetTexture = renderTexture;\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        if (Time.time - lastUpdateTime >= updateInterval)\r\n        {\r\n            PublishImage();\r\n            lastUpdateTime = Time.time;\r\n        }\r\n    }\r\n\r\n    void PublishImage()\r\n    {\r\n        // Get image from render texture\r\n        RenderTexture.active = renderTexture;\r\n        Texture2D image = new Texture2D(imageWidth, imageHeight, TextureFormat.RGB24, false);\r\n        image.ReadPixels(new Rect(0, 0, imageWidth, imageHeight), 0, 0);\r\n        image.Apply();\r\n        RenderTexture.active = null;\r\n\r\n        // Convert to ROS message\r\n        byte[] imageData = image.EncodeToJPG();\r\n        Destroy(image);\r\n\r\n        // Create ROS message\r\n        var msg = new ImageMsg\r\n        {\r\n            header = new HeaderMsg\r\n            {\r\n                stamp = new TimeStamp(Time.time),\r\n                frame_id = transform.name\r\n            },\r\n            height = (uint)imageHeight,\r\n            width = (uint)imageWidth,\r\n            encoding = "rgb8",\r\n            is_bigendian = 0,\r\n            step = (uint)(imageWidth * 3), // 3 bytes per pixel\r\n            data = imageData\r\n        };\r\n\r\n        // Publish to ROS\r\n        ros.Send(topicName, msg);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-lidar-simulation",children:"2. LIDAR Simulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing System.Collections.Generic;\r\nusing Unity.Robotics.ROSTCPConnector;\r\nusing RosMessageTypes.Sensor;\r\nusing RosMessageTypes.Std;\r\n\r\npublic class UnityLIDARSensor : MonoBehaviour\r\n{\r\n    [Header("LIDAR Settings")]\r\n    public int horizontalSamples = 360;\r\n    public float maxDistance = 30f;\r\n    public float minAngle = -180f;\r\n    public float maxAngle = 180f;\r\n    public string topicName = "/scan";\r\n    public float updateRate = 10f;\r\n\r\n    [Header("Physics")]\r\n    public LayerMask obstacleLayer = -1;\r\n\r\n    private ROSConnection ros;\r\n    private float updateInterval;\r\n    private float lastUpdateTime;\r\n\r\n    void Start()\r\n    {\r\n        ros = ROSConnection.GetOrCreateInstance();\r\n        updateInterval = 1.0f / updateRate;\r\n        lastUpdateTime = 0f;\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        if (Time.time - lastUpdateTime >= updateInterval)\r\n        {\r\n            PublishLIDARData();\r\n            lastUpdateTime = Time.time;\r\n        }\r\n    }\r\n\r\n    void PublishLIDARData()\r\n    {\r\n        List<float> ranges = new List<float>();\r\n        float angleIncrement = (maxAngle - minAngle) / horizontalSamples;\r\n\r\n        for (int i = 0; i < horizontalSamples; i++)\r\n        {\r\n            float angle = minAngle + (i * angleIncrement);\r\n            float radAngle = Mathf.Deg2Rad * angle;\r\n\r\n            Vector3 direction = new Vector3(\r\n                Mathf.Cos(radAngle),\r\n                0,\r\n                Mathf.Sin(radAngle)\r\n            ).normalized;\r\n\r\n            Ray ray = new Ray(transform.position, transform.TransformDirection(direction));\r\n            RaycastHit hit;\r\n\r\n            if (Physics.Raycast(ray, out hit, maxDistance, obstacleLayer))\r\n            {\r\n                ranges.Add(hit.distance);\r\n            }\r\n            else\r\n            {\r\n                ranges.Add(maxDistance);\r\n            }\r\n        }\r\n\r\n        // Create ROS LaserScan message\r\n        var msg = new LaserScanMsg\r\n        {\r\n            header = new HeaderMsg\r\n            {\r\n                stamp = new TimeStamp(Time.time),\r\n                frame_id = transform.name\r\n            },\r\n            angle_min = minAngle * Mathf.Deg2Rad,\r\n            angle_max = maxAngle * Mathf.Deg2Rad,\r\n            angle_increment = angleIncrement * Mathf.Deg2Rad,\r\n            time_increment = 0,\r\n            scan_time = 1.0f / updateRate,\r\n            range_min = 0.1f,\r\n            range_max = maxDistance,\r\n            ranges = ranges.ToArray(),\r\n            intensities = new float[ranges.Count] // Empty intensities array\r\n        };\r\n\r\n        ros.Send(topicName, msg);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-imu-simulation",children:"3. IMU Simulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing Unity.Robotics.ROSTCPConnector;\r\nusing RosMessageTypes.Sensor;\r\nusing RosMessageTypes.Geometry;\r\nusing RosMessageTypes.Std;\r\n\r\npublic class UnityIMUMsg : MonoBehaviour\r\n{\r\n    [Header("Noise Parameters")]\r\n    public float linearAccelerationNoise = 0.01f;\r\n    public float angularVelocityNoise = 0.001f;\r\n    public float orientationNoise = 0.001f;\r\n\r\n    [Header("Update Settings")]\r\n    public string topicName = "/imu/data";\r\n    public float updateRate = 100f;\r\n\r\n    private ROSConnection ros;\r\n    private Rigidbody attachedRigidbody;\r\n    private float updateInterval;\r\n    private float lastUpdateTime;\r\n\r\n    void Start()\r\n    {\r\n        ros = ROSConnection.GetOrCreateInstance();\r\n        attachedRigidbody = GetComponent<Rigidbody>();\r\n        updateInterval = 1.0f / updateRate;\r\n        lastUpdateTime = 0f;\r\n    }\r\n\r\n    void FixedUpdate()\r\n    {\r\n        if (Time.time - lastUpdateTime >= updateInterval)\r\n        {\r\n            PublishIMUData();\r\n            lastUpdateTime = Time.time;\r\n        }\r\n    }\r\n\r\n    void PublishIMUData()\r\n    {\r\n        // Get data from rigidbody\r\n        Vector3 linearAcc = attachedRigidbody.velocity / Time.fixedDeltaTime;\r\n        Vector3 angularVel = attachedRigidbody.angularVelocity;\r\n\r\n        // Add noise\r\n        linearAcc += Random.insideUnitSphere * linearAccelerationNoise;\r\n        angularVel += Random.insideUnitSphere * angularVelocityNoise;\r\n\r\n        // Create orientation (simplified - in real application you\'d need proper orientation)\r\n        Quaternion orientation = transform.rotation;\r\n        orientation = AddOrientationNoise(orientation);\r\n\r\n        // Create ROS IMU message\r\n        var msg = new ImuMsg\r\n        {\r\n            header = new HeaderMsg\r\n            {\r\n                stamp = new TimeStamp(Time.time),\r\n                frame_id = transform.name\r\n            },\r\n            orientation = new QuaternionMsg\r\n            {\r\n                x = orientation.x,\r\n                y = orientation.y,\r\n                z = orientation.z,\r\n                w = orientation.w\r\n            },\r\n            orientation_covariance = new double[] {\r\n                orientationNoise, 0, 0, 0, orientationNoise, 0, 0, 0, orientationNoise\r\n            },\r\n            angular_velocity = new Vector3Msg\r\n            {\r\n                x = angularVel.x,\r\n                y = angularVel.y,\r\n                z = angularVel.z\r\n            },\r\n            angular_velocity_covariance = new double[] {\r\n                angularVelocityNoise, 0, 0, 0, angularVelocityNoise, 0, 0, 0, angularVelocityNoise\r\n            },\r\n            linear_acceleration = new Vector3Msg\r\n            {\r\n                x = linearAcc.x,\r\n                y = linearAcc.y,\r\n                z = linearAcc.z\r\n            },\r\n            linear_acceleration_covariance = new double[] {\r\n                linearAccelerationNoise, 0, 0, 0, linearAccelerationNoise, 0, 0, 0, linearAccelerationNoise\r\n            }\r\n        };\r\n\r\n        ros.Send(topicName, msg);\r\n    }\r\n\r\n    Quaternion AddOrientationNoise(Quaternion original)\r\n    {\r\n        Vector3 noise = Random.insideUnitSphere * orientationNoise;\r\n        return original * Quaternion.Euler(noise);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"unity-ros-communication",children:"Unity-ROS Communication"}),"\n",(0,t.jsx)(e.h3,{id:"1-setting-up-ros-connection",children:"1. Setting up ROS Connection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing Unity.Robotics.ROSTCPConnector;\r\n\r\npublic class ROSManager : MonoBehaviour\r\n{\r\n    public string rosIPAddress = "127.0.0.1";\r\n    public int rosPort = 10000;\r\n\r\n    private static ROSConnection rosConnection;\r\n\r\n    void Start()\r\n    {\r\n        // Get or create ROS connection\r\n        rosConnection = ROSConnection.GetOrCreateInstance();\r\n        rosConnection.Initialize(rosIPAddress, rosPort);\r\n    }\r\n\r\n    public static ROSConnection GetROSConnection()\r\n    {\r\n        return rosConnection;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-subscribing-to-ros-topics",children:"2. Subscribing to ROS Topics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing Unity.Robotics.ROSTCPConnector;\r\nusing RosMessageTypes.Geometry;\r\n\r\npublic class ROSSubscriberExample : MonoBehaviour\r\n{\r\n    public string topicName = "/cmd_vel";\r\n\r\n    void Start()\r\n    {\r\n        // Subscribe to ROS topic\r\n        ROSConnection.GetOrCreateInstance().Subscribe<TwistMsg>(topicName, ReceiveCmdVel);\r\n    }\r\n\r\n    void ReceiveCmdVel(TwistMsg cmdVel)\r\n    {\r\n        // Process the received velocity command\r\n        float linearX = (float)cmdVel.linear.x;\r\n        float angularZ = (float)cmdVel.angular.z;\r\n\r\n        // Apply to robot movement\r\n        ApplyVelocityCommand(linearX, angularZ);\r\n    }\r\n\r\n    void ApplyVelocityCommand(float linear, float angular)\r\n    {\r\n        // Implement your robot\'s velocity control logic here\r\n        Debug.Log($"Received velocity command: linear={linear}, angular={angular}");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-unity-robotics-features",children:"Advanced Unity Robotics Features"}),"\n",(0,t.jsx)(e.h3,{id:"1-ml-agents-integration",children:"1. ML-Agents Integration"}),"\n",(0,t.jsx)(e.p,{children:"Unity ML-Agents can be used for training robotic behaviors:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using Unity.MLAgents;\r\nusing Unity.MLAgents.Sensors;\r\nusing Unity.MLAgents.Actuators;\r\nusing UnityEngine;\r\n\r\npublic class RobotAgent : Agent\r\n{\r\n    [Header("Robot Components")]\r\n    public RobotController robotController;\r\n    public Transform target;\r\n\r\n    public override void OnEpisodeBegin()\r\n    {\r\n        // Reset robot and target positions\r\n        transform.position = new Vector3(Random.Range(-5f, 5f), 0.5f, Random.Range(-5f, 5f));\r\n        target.position = new Vector3(Random.Range(-4f, 4f), 0.5f, Random.Range(-4f, 4f));\r\n    }\r\n\r\n    public override void CollectObservations(VectorSensor sensor)\r\n    {\r\n        // Distance to target\r\n        Vector3 distanceToTarget = target.position - transform.position;\r\n        sensor.AddObservation(distanceToTarget.normalized);\r\n        sensor.AddObservation(distanceToTarget.magnitude);\r\n\r\n        // Robot velocity\r\n        sensor.AddObservation(robotController.GetLinearVelocity());\r\n        sensor.AddObservation(robotController.GetAngularVelocity());\r\n\r\n        // Robot orientation relative to target\r\n        sensor.AddObservation(Vector3.Dot(transform.forward, distanceToTarget.normalized));\r\n    }\r\n\r\n    public override void OnActionReceived(ActionBuffers actions)\r\n    {\r\n        float forward = actions.ContinuousActions[0];\r\n        float turn = actions.ContinuousActions[1];\r\n\r\n        robotController.SetWheelVelocities(forward - turn, forward + turn);\r\n\r\n        // Reward based on distance to target\r\n        float distanceToTarget = Vector3.Distance(transform.position, target.position);\r\n        SetReward(-distanceToTarget / 10f);\r\n\r\n        // End episode if reached target\r\n        if (distanceToTarget < 1f)\r\n        {\r\n            SetReward(1f);\r\n            EndEpisode();\r\n        }\r\n\r\n        // End episode if too far away\r\n        if (distanceToTarget > 20f)\r\n        {\r\n            EndEpisode();\r\n        }\r\n    }\r\n\r\n    public override void Heuristic(in ActionBuffers actionsOut)\r\n    {\r\n        var continuousActionsOut = actionsOut.ContinuousActions;\r\n        continuousActionsOut[0] = Input.GetAxis("Vertical"); // Forward/back\r\n        continuousActionsOut[1] = Input.GetAxis("Horizontal"); // Turn left/right\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-physics-optimization",children:"2. Physics Optimization"}),"\n",(0,t.jsx)(e.p,{children:"For better performance in robotics simulation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class PhysicsOptimizer : MonoBehaviour\r\n{\r\n    [Header("Physics Settings")]\r\n    public bool useInterpolation = true;\r\n    public float sleepThreshold = 0.005f;\r\n    public int solverIterations = 6;\r\n    public int solverVelocityIterations = 1;\r\n\r\n    void Start()\r\n    {\r\n        OptimizePhysics();\r\n    }\r\n\r\n    void OptimizePhysics()\r\n    {\r\n        // Adjust physics settings for robotics simulation\r\n        Physics.autoSimulation = true;\r\n        Physics.defaultSolverIterations = solverIterations;\r\n        Physics.defaultSolverVelocityIterations = solverVelocityIterations;\r\n        Physics.sleepThreshold = sleepThreshold;\r\n\r\n        // Apply settings to robot components\r\n        Rigidbody[] rigidbodies = GetComponentsInChildren<Rigidbody>();\r\n        foreach (Rigidbody rb in rigidbodies)\r\n        {\r\n            rb.interpolation = useInterpolation ?\r\n                RigidbodyInterpolation.Interpolate :\r\n                RigidbodyInterpolation.None;\r\n            rb.sleepThreshold = sleepThreshold;\r\n            rb.solverIterations = solverIterations;\r\n            rb.solverVelocityIterations = solverVelocityIterations;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-unity-robotics",children:"Best Practices for Unity Robotics"}),"\n",(0,t.jsx)(e.h3,{id:"1-performance-optimization",children:"1. Performance Optimization"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use object pooling for frequently instantiated objects"}),"\n",(0,t.jsx)(e.li,{children:"Optimize mesh complexity for collision detection"}),"\n",(0,t.jsx)(e.li,{children:"Use appropriate update rates for different sensors"}),"\n",(0,t.jsx)(e.li,{children:"Implement Level of Detail (LOD) for complex scenes"}),"\n",(0,t.jsx)(e.li,{children:"Consider using Unity's Job System for parallel processing"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-accuracy-considerations",children:"2. Accuracy Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Calibrate Unity physics to match real-world behavior"}),"\n",(0,t.jsx)(e.li,{children:"Use realistic sensor noise models"}),"\n",(0,t.jsx)(e.li,{children:"Validate simulation results against real-world data"}),"\n",(0,t.jsx)(e.li,{children:"Account for rendering vs. physics timestep differences"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"3-integration-strategies",children:"3. Integration Strategies"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement proper error handling for ROS connections"}),"\n",(0,t.jsx)(e.li,{children:"Use appropriate coordinate system conversions"}),"\n",(0,t.jsx)(e.li,{children:"Handle network latency in real-time applications"}),"\n",(0,t.jsx)(e.li,{children:"Implement graceful degradation when ROS connection fails"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,t.jsx)(e.h3,{id:"1-physics-issues",children:"1. Physics Issues"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Problem"}),": Objects behaving unrealistically"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),": Adjust physics material properties, check mass and drag values"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-performance-issues",children:"2. Performance Issues"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Problem"}),": Low frame rate in complex scenes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),": Reduce polygon count, use occlusion culling, optimize draw calls"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"3-ros-connection-issues",children:"3. ROS Connection Issues"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Problem"}),": Connection failures or high latency"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),": Check IP addresses, firewall settings, network configuration"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"comparison-with-other-simulation-platforms",children:"Comparison with Other Simulation Platforms"}),"\n",(0,t.jsx)(e.h3,{id:"unity-vs-gazebo",children:"Unity vs. Gazebo"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unity"}),": Superior rendering, easier visual environment creation, game engine features"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo"}),": Better physics accuracy, native ROS integration, robotics-specific tools"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Practice"}),": Use Unity for visualization and Gazebo for physics-critical applications"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(e.p,{children:"[All sources will be cited in the References section at the end of the book, following APA format]"})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,r){r.d(e,{R:()=>a,x:()=>s});var i=r(6540);const t={},o=i.createContext(t);function a(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);